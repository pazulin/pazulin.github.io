{"meta":{"title":"逍遥游","subtitle":null,"description":null,"author":"井蛙","url":"https://pazulin.github.io"},"pages":[{"title":"所有分类","date":"2019-07-31T10:51:00.668Z","updated":"2019-07-31T10:51:00.668Z","comments":true,"path":"categories/index.html","permalink":"https://pazulin.github.io/categories/index.html","excerpt":"","keywords":null,"text":"","raw":null,"content":null},{"title":"关于","date":"2020-12-08T15:16:13.183Z","updated":"2020-12-08T15:16:13.183Z","comments":true,"path":"about/index.html","permalink":"https://pazulin.github.io/about/index.html","excerpt":"","keywords":null,"text":"没有什么说的. 为了增加访问率https://pazulin.github.io/http://blog.munu.tech/","raw":null,"content":null}],"posts":[{"title":"volumio增加外置显示屏和按键","slug":"volumio-display-key","date":"2025-10-31T23:35:31.000Z","updated":"2025-10-31T23:48:44.850Z","comments":true,"path":"2025/11/01/volumio-display-key/","permalink":"https://pazulin.github.io/2025/11/01/volumio-display-key/","excerpt":"","keywords":null,"text":"Q7上面跑volumio 2.8,增加一个ESP32C3 的模块, 这个模块有显示屏和按键,显示屏接的是1.3寸OLED 显示屏, 按键接的是一个4个按键的模块,分别接到ESP32C3的GPIO python 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426# -*- coding: utf-8 -*-import serialimport timeimport jsonimport requestsimport loggingfrom threading import Threadfrom Queue import Queueimport sys# 重新加载sys并设置默认编码reload(sys)sys.setdefaultencoding(&#x27;utf-8&#x27;)# 配置日志 - 抑制 requests 和 urllib3 的日志logging.basicConfig(level=logging.INFO, format=&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;)logging.getLogger(&quot;requests&quot;).setLevel(logging.WARNING)logging.getLogger(&quot;urllib3&quot;).setLevel(logging.WARNING)SERIAL_PORT = &#x27;/dev/ttyACM0&#x27;BAUD_RATE = 115200VOLUMIO_HOST = &#x27;localhost&#x27;VOLUMIO_PORT = 3000GET_STATE = &#x27;http://&#123;&#125;:&#123;&#125;/api/v1/getState&#x27;.format(VOLUMIO_HOST, VOLUMIO_PORT)GET_QUEUE = &#x27;http://&#123;&#125;:&#123;&#125;/api/v1/getQueue&#x27;.format(VOLUMIO_HOST, VOLUMIO_PORT)SEEK_UPDATE_INTERVAL = 2MAX_RETRIES = 3RETRY_DELAY = 5# 创建会话对象，支持连接复用session = requests.Session()class VolumioController: def __init__(self): self.ser = None self.command_queue = Queue() self.running = True self.volumio_available = True self.serial_available = False self.last_state_data = None self.last_queue_data = None self.data_cache_time = 0 self.queue_cache_time = 0 self.last_position = -1 # 记录上次的位置 self.last_uri = &quot;&quot; # 记录上次的URI，用于检测文件夹切换 self.cache_duration = 1.0 # 状态缓存1秒 self.queue_cache_duration = 2.0 # 队列缓存2秒，减少时间 def init_serial(self): &quot;&quot;&quot;初始化串口连接，支持重试&quot;&quot;&quot; retry_count = 0 while retry_count &lt; MAX_RETRIES and self.running: try: self.ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.5) self.serial_available = True logging.info(&quot;串口连接成功: %s&quot;, SERIAL_PORT) return True except Exception as e: retry_count += 1 logging.error(&quot;串口连接失败 (尝试 %d/%d): %s&quot;, retry_count, MAX_RETRIES, str(e)) if retry_count &lt; MAX_RETRIES: time.sleep(RETRY_DELAY) logging.error(&quot;无法建立串口连接，程序退出&quot;) return False # def truncate_song_name(self, name, max_length=10): # &quot;&quot;&quot;截断歌曲名称，直接截取前max_length个字符&quot;&quot;&quot; # if not name: # return u&quot;未知歌曲&quot; # # 确保是unicode字符串 # if not isinstance(name, unicode): # try: # name = name.decode(&#x27;utf-8&#x27;) # except: # name = u&quot;未知歌曲&quot; # if len(name) &lt;= max_length: # return name # # 直接截取前max_length个字符，不加省略号 # return name[:max_length] def truncate_song_name(self, name, max_chinese=10, max_english=20): &quot;&quot;&quot;截断歌曲名称，如果包含中文就用10个字符，否则用20个字符&quot;&quot;&quot; if not name: return u&quot;未知歌曲&quot; # 确保是unicode字符串 if not isinstance(name, unicode): try: name = name.decode(&#x27;utf-8&#x27;) except: return u&quot;未知歌曲&quot; # 检查是否包含中文字符 has_chinese = any(u&#x27;\\u4e00&#x27; &lt;= char &lt;= u&#x27;\\u9fff&#x27; for char in name) # 选择最大长度 max_length = max_chinese if has_chinese else max_english if len(name) &lt;= max_length: return name return name[:max_length] def safe_volumio_request(self, url, timeout=2, use_cache=False, cache_type=&quot;state&quot;): &quot;&quot;&quot;安全的Volumio请求，带重试机制和缓存&quot;&quot;&quot; current_time = time.time() # 使用缓存数据（如果可用且未过期） if use_cache: cache_duration = self.cache_duration if cache_type == &quot;state&quot; else self.queue_cache_duration cache_time = self.data_cache_time if cache_type == &quot;state&quot; else self.queue_cache_time cache_data = self.last_state_data if cache_type == &quot;state&quot; else self.last_queue_data if cache_data and current_time - cache_time &lt; cache_duration: if url == GET_STATE and cache_type == &quot;state&quot;: return self.last_state_data elif url == GET_QUEUE and cache_type == &quot;queue&quot;: return self.last_queue_data for attempt in range(MAX_RETRIES): try: response = session.get(url, timeout=timeout) if response.status_code == 200: self.volumio_available = True data = response.json() # 缓存数据 if url == GET_STATE: self.last_state_data = data self.data_cache_time = current_time elif url == GET_QUEUE: self.last_queue_data = data self.queue_cache_time = current_time return data else: logging.warning(&quot;Volumio返回错误状态码: %d&quot;, response.status_code) except Exception as e: logging.warning(&quot;Volumio请求失败 (尝试 %d/%d): %s&quot;, attempt + 1, MAX_RETRIES, str(e)) if attempt &lt; MAX_RETRIES - 1: time.sleep(1) self.volumio_available = False logging.error(&quot;Volumio服务不可用&quot;) return None def get_volumio_status(self): &quot;&quot;&quot;获取Volumio状态，带降级处理&quot;&quot;&quot; state_data = self.safe_volumio_request(GET_STATE, use_cache=True, cache_type=&quot;state&quot;) if not state_data: return self.get_fallback_status() try: # 修正字段映射 seek_ms = state_data.get(&#x27;seek&#x27;, 0) # 毫秒 seek = int(seek_ms / 1000) # 转换为秒 duration = int(state_data.get(&#x27;duration&#x27;, 1) or 1) title = state_data.get(&#x27;title&#x27;, u&#x27;无歌曲&#x27;) status = state_data.get(&#x27;status&#x27;, &#x27;stop&#x27;) current_position = int(state_data.get(&#x27;position&#x27;, -1)) # 队列中的位置 current_uri = state_data.get(&#x27;uri&#x27;, &#x27;&#x27;) # 当前歌曲的URI # 检测文件夹切换 - 如果URI路径发生变化，强制刷新队列 force_queue_update = False if current_uri and self.last_uri: # 提取文件夹路径进行比较 current_folder = &#x27;/&#x27;.join(current_uri.split(&#x27;/&#x27;)[:-1]) last_folder = &#x27;/&#x27;.join(self.last_uri.split(&#x27;/&#x27;)[:-1]) if current_folder != last_folder: logging.info(&quot;检测到文件夹切换，强制刷新队列&quot;) force_queue_update = True self.last_uri = current_uri # 简化歌曲名称显示 - 当前歌曲保留完整名称 display_title = self.truncate_song_name(title, 30) # 当前歌曲显示30个字符 # 只有当需要时才获取队列信息 prev_song = u&#x27;无&#x27; next_song = u&#x27;无&#x27; if status == &#x27;play&#x27; or status == &#x27;pause&#x27;: # 检查位置是否改变或需要强制更新 position_changed = (current_position != self.last_position) if position_changed or force_queue_update: logging.info(&quot;位置变化或强制更新，重新获取队列信息&quot;) prev_song, next_song = self.get_queue_info( current_position, force_update=(position_changed or force_queue_update) ) self.last_position = current_position return &#123; &quot;title&quot;: display_title, &quot;prevSong&quot;: prev_song, &quot;nextSong&quot;: next_song, &quot;duration&quot;: duration, &quot;seek&quot;: seek, &quot;status&quot;: status &#125; except Exception as e: logging.error(&quot;解析Volumio状态数据失败: %s, 原始数据: %s&quot;, str(e), state_data) return self.get_fallback_status() def get_queue_info(self, position, force_update=False): &quot;&quot;&quot;获取队列信息&quot;&quot;&quot; # 修正：只有当位置有效时才获取队列 if position &lt; 0: return u&#x27;无&#x27;, u&#x27;无&#x27; # 如果强制更新，不使用缓存 use_cache = not force_update queue_data = self.safe_volumio_request(GET_QUEUE, use_cache=use_cache, cache_type=&quot;queue&quot;) if not queue_data: return u&#x27;未知&#x27;, u&#x27;未知&#x27; try: queue = queue_data.get(&#x27;queue&#x27;, []) prev_song = u&#x27;无&#x27; next_song = u&#x27;无&#x27; if 0 &lt;= position &lt; len(queue): if position &gt; 0: prev_item = queue[position - 1] # 尝试多个可能的字段名 prev_name = prev_item.get(&#x27;name&#x27;, prev_item.get(&#x27;title&#x27;, u&#x27;无&#x27;)) # 队列中的歌曲名称截取前10个字符 prev_song = self.truncate_song_name(prev_name, 10) if position &lt; len(queue) - 1: next_item = queue[position + 1] # 尝试多个可能的字段名 next_name = next_item.get(&#x27;name&#x27;, next_item.get(&#x27;title&#x27;, u&#x27;无&#x27;)) # 队列中的歌曲名称截取前10个字符 next_song = self.truncate_song_name(next_name, 10) logging.debug(&quot;队列信息: 位置=%d, 上一首=%s, 下一首=%s&quot;, position, prev_song, next_song) return prev_song, next_song except Exception as e: logging.error(&quot;解析队列信息失败: %s, 队列数据: %s&quot;, str(e), queue_data) return u&#x27;未知&#x27;, u&#x27;未知&#x27; def get_fallback_status(self): &quot;&quot;&quot;返回降级状态&quot;&quot;&quot; return &#123; &quot;title&quot;: u&quot;服务不可用&quot;, &quot;prevSong&quot;: u&quot;未知&quot;, &quot;nextSong&quot;: u&quot;未知&quot;, &quot;duration&quot;: 1, &quot;seek&quot;: 0, &quot;status&quot;: &quot;stop&quot; &#125; def safe_serial_send(self, data): &quot;&quot;&quot;安全的串口数据发送&quot;&quot;&quot; if not self.serial_available or not self.ser: return False try: # 确保所有字符串都是UTF-8编码的普通字符串，而不是Unicode对象 ascii_safe_data = &#123;&#125; for key, value in data.items(): if isinstance(value, unicode): # 将Unicode转换为UTF-8编码的字符串 ascii_safe_data[key] = value.encode(&#x27;utf-8&#x27;) else: ascii_safe_data[key] = value # 使用 ensure_ascii=False 来支持中文 json_str = json.dumps(ascii_safe_data, ensure_ascii=False) + &#x27;\\n&#x27; # 在 Python 2.7 中，需要显式编码为 UTF-8 self.ser.write(json_str.encode(&#x27;utf-8&#x27;)) return True except Exception as e: logging.error(&quot;串口发送失败: %s&quot;, str(e)) self.serial_available = False self.try_reconnect_serial() return False def try_reconnect_serial(self): &quot;&quot;&quot;尝试重新连接串口&quot;&quot;&quot; if self.ser: try: self.ser.close() except: pass logging.info(&quot;尝试重新连接串口...&quot;) self.serial_available = self.init_serial() def handle_esp32_command(self, cmd): &quot;&quot;&quot;处理ESP32命令&quot;&quot;&quot; cmd = cmd.strip().upper() command_urls = &#123; &#x27;PLAY&#x27;: &#x27;http://&#123;&#125;:&#123;&#125;/api/v1/commands/?cmd=play&#x27;.format(VOLUMIO_HOST, VOLUMIO_PORT), &#x27;PAUSE&#x27;: &#x27;http://&#123;&#125;:&#123;&#125;/api/v1/commands/?cmd=pause&#x27;.format(VOLUMIO_HOST, VOLUMIO_PORT), &#x27;NEXT&#x27;: &#x27;http://&#123;&#125;:&#123;&#125;/api/v1/commands/?cmd=next&#x27;.format(VOLUMIO_HOST, VOLUMIO_PORT), &#x27;PREV&#x27;: &#x27;http://&#123;&#125;:&#123;&#125;/api/v1/commands/?cmd=prev&#x27;.format(VOLUMIO_HOST, VOLUMIO_PORT) &#125; if cmd in command_urls: # 执行命令后，强制更新队列信息 self.safe_volumio_request(command_urls[cmd], timeout=1) # 清除队列缓存，确保下次获取最新数据 self.last_queue_data = None self.queue_cache_time = 0 # 重置位置跟踪 self.last_position = -1 else: logging.warning(&quot;未知命令: %s&quot;, cmd) def read_serial_commands(self): &quot;&quot;&quot;读取串口命令的独立线程&quot;&quot;&quot; while self.running: if self.serial_available and self.ser and self.ser.inWaiting(): try: line = self.ser.readline().strip() if line: # Python 2.7 解码处理 try: line = line.decode(&#x27;utf-8&#x27;) except UnicodeDecodeError: try: line = line.decode(&#x27;gbk&#x27;) except: line = line.decode(&#x27;latin-1&#x27;) logging.info(&quot;收到ESP32命令: %s&quot;, line) self.handle_esp32_command(line) except Exception as e: logging.error(&quot;串口读取错误: %s&quot;, str(e)) self.serial_available = False time.sleep(0.1) def run(self): &quot;&quot;&quot;主运行循环&quot;&quot;&quot; if not self.init_serial(): return # 启动串口读取线程 serial_thread = Thread(target=self.read_serial_commands) serial_thread.daemon = True serial_thread.start() last_title = &quot;&quot; last_status = &quot;&quot; last_seek_sent = -1 last_seek_time = time.time() last_health_check = time.time() last_full_update = 0 while self.running: try: current_time = time.time() # 健康检查（减少频率） if current_time - last_health_check &gt; 30: if not self.volumio_available: logging.info(&quot;尝试恢复Volumio连接...&quot;) test_data = self.safe_volumio_request(GET_STATE, timeout=1) if test_data: logging.info(&quot;Volumio连接已恢复&quot;) last_health_check = current_time # 获取状态并发送 song_info = self.get_volumio_status() now = time.time() # 减少完整状态发送频率 needs_full_update = (song_info[&#x27;title&#x27;] != last_title or song_info[&#x27;status&#x27;] != last_status or now - last_full_update &gt; 30) # 每30秒强制更新一次 if needs_full_update: if self.safe_serial_send(song_info): last_title = song_info[&#x27;title&#x27;] last_status = song_info[&#x27;status&#x27;] last_seek_sent = song_info[&#x27;seek&#x27;] last_seek_time = now last_full_update = now # 如果正在播放且 seek 超过更新时间间隔 → 发送 seek 更新 elif (song_info[&#x27;status&#x27;] == &#x27;play&#x27; and (now - last_seek_time &gt;= SEEK_UPDATE_INTERVAL)): if song_info[&#x27;seek&#x27;] != last_seek_sent: if self.safe_serial_send(&#123;&quot;seek&quot;: song_info[&#x27;seek&#x27;]&#125;): last_seek_sent = song_info[&#x27;seek&#x27;] last_seek_time = now time.sleep(0.2) # 增加休眠时间，减少请求频率 except Exception as e: logging.error(&quot;主循环发生未预期错误: %s&quot;, str(e)) time.sleep(1) def stop(self): &quot;&quot;&quot;停止运行&quot;&quot;&quot; self.running = False if self.ser: try: self.ser.close() except: pass session.close()def main(): controller = VolumioController() try: controller.run() except KeyboardInterrupt: logging.info(&quot;收到中断信号，程序退出&quot;) except Exception as e: logging.error(&quot;程序运行出错: %s&quot;, str(e)) finally: controller.stop()if __name__ == &#x27;__main__&#x27;: main() 把这个脚本加入系统服务sudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;esp32_remote.service 1234567891011121314151617[Unit]Description=ESP32 Volumio Remote Control ServiceAfter=network.target[Service]Type=simpleUser=volumioWorkingDirectory=/home/volumioExecStart=/usr/bin/python /home/volumio/remote_esp32.pyRestart=alwaysRestartSec=5[Install]WantedBy=multi-user.target ESP32 那边代码如下,主要部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422sudo systemctl daemon-reloadsudo systemctl start esp32_remote.servicesudo systemctl status esp32_remote.service// 初始化 SH1106，I2C 接口U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE, /* SCL=*/ 5, // 自定义 SCL 引脚 /* SDA=*/ 4 // 自定义 SDA 引脚 );// 定义按键引脚#define BUTTON_PAUSE 8 // GPIO0 连接按键1（暂停）#define BUTTON_PLAY 20 // GPIO1 连接按键2（播放）#define BUTTON_NEXT 21 // GPIO2 连接按键3（下一首）#define BUTTON_PREV 1 // GPIO3 连接按键4（上一首）#define BUTTON_SONG1 2 // GPIO4 连接按键5（歌曲1）#define BUTTON_SONG2 10 // GPIO5 连接按键6（歌曲2）#define BUTTON_SONG3 6 // GPIO6 连接按键7（歌曲3）#define BUTTON_SONG4 7 // GPIO7 连接按键8（歌曲4）// 歌曲信息结构体struct SongInfo &#123; String title; String prevSong; // 上一首歌曲 String nextSong; // 下一首歌曲 int duration; int seek; String status;&#125;;// 命令定义enum Command &#123; CMD_PLAY, CMD_PAUSE, CMD_NEXT, CMD_PREV, CMD_PLAY_SONG&#125;;// 按钮状态跟踪（用于防抖）unsigned long lastPressTime = 0;const uint16_t DEBOUNCE_DELAY = 600; // 防抖延迟(ms)// 添加全局变量用于息屏控制unsigned long lastActiveTime = 0; // 最后一次活动时间const unsigned long SCREEN_OFF_DELAY = 10 * 60 * 1000; // 10分钟（毫秒）bool screenOn = true; // 屏幕状态SongInfo lastInfo;// 发送命令到串口void sendCommand(Command cmd, int dataLength = 0, byte* data = nullptr) &#123; switch(cmd) &#123; case CMD_PLAY: Serial.println(&quot;PLAY&quot;); // 使用println自动添加\\r\\n break; case CMD_PAUSE: Serial.println(&quot;PAUSE&quot;); break; case CMD_NEXT: Serial.println(&quot;NEXT&quot;); break; case CMD_PREV: Serial.println(&quot;PREV&quot;); break; case CMD_PLAY_SONG: if(dataLength &gt; 0 &amp;&amp; data != nullptr) &#123; Serial.print(&quot;SONG:&quot;); Serial.println(data[0]); // 使用println &#125; break; &#125; delay(20); // 给 Linux 足够时间接收 Serial.flush();&#125;// 关闭屏幕void turnOffScreen() &#123; u8g2.clearBuffer(); u8g2.sendBuffer(); screenOn = false;&#125;// 打开屏幕void turnOnScreen() &#123; screenOn = true; // 屏幕内容会在下次updateDisplay调用时刷新&#125;// 修改按键处理函数，返回是否有按键按下bool handleButtonPress() &#123; // 防抖检查 static unsigned long lastPressTime = 0; if (millis() - lastPressTime &lt; DEBOUNCE_DELAY) return false; bool buttonPressed = false; // 检测按键按下（低电平触发） if (digitalRead(BUTTON_PLAY) == LOW) &#123; sendCommand(CMD_PLAY); lastPressTime = millis(); buttonPressed = true; &#125; else if (digitalRead(BUTTON_PAUSE) == LOW) &#123; sendCommand(CMD_PAUSE); lastPressTime = millis(); buttonPressed = true; &#125; else if (digitalRead(BUTTON_NEXT) == LOW) &#123; sendCommand(CMD_NEXT); lastPressTime = millis(); buttonPressed = true; &#125; else if (digitalRead(BUTTON_PREV) == LOW) &#123; sendCommand(CMD_PREV); lastPressTime = millis(); buttonPressed = true; &#125; #if GATEWAY else if (digitalRead(BUTTON_SONG1) == LOW) &#123; byte songNum = 1; sendCommand(CMD_PLAY_SONG, 1, &amp;songNum); lastPressTime = millis(); buttonPressed = true; &#125; else if (digitalRead(BUTTON_SONG2) == LOW) &#123; byte songNum = 2; sendCommand(CMD_PLAY_SONG, 1, &amp;songNum); lastPressTime = millis(); buttonPressed = true; &#125; else if (digitalRead(BUTTON_SONG3) == LOW) &#123; byte songNum = 3; sendCommand(CMD_PLAY_SONG, 1, &amp;songNum); lastPressTime = millis(); buttonPressed = true; &#125; else if (digitalRead(BUTTON_SONG4) == LOW) &#123; byte songNum = 4; sendCommand(CMD_PLAY_SONG, 1, &amp;songNum); lastPressTime = millis(); buttonPressed = true; &#125; #endif if (buttonPressed) &#123; if (!screenOn) turnOnScreen(); lastActiveTime = millis(); &#125; return buttonPressed;&#125;void setup() &#123; pinMode(BUTTON_PAUSE, INPUT_PULLUP); pinMode(BUTTON_PLAY, INPUT_PULLUP); pinMode(BUTTON_NEXT, INPUT_PULLUP); pinMode(BUTTON_PREV, INPUT_PULLUP); #if GATEWAY pinMode(BUTTON_SONG1, INPUT_PULLUP); pinMode(BUTTON_SONG2, INPUT_PULLUP); pinMode(BUTTON_SONG3, INPUT_PULLUP); pinMode(BUTTON_SONG4, INPUT_PULLUP); #endif Serial.begin (115200); //Mount FS Serial.println(&quot;Mounting FS...&quot;); if (!SPIFFS.begin(true)) &#123; //Serial.println(&quot;SPIFFS mount failed&quot;); return; &#125; u8g2.begin(); // 初始化屏幕 u8g2.clearBuffer(); // 清空缓冲区 u8g2.setFont(u8g2_font_wqy12_t_gb2312); u8g2.setContrast(0); // 设置对比度 (0-255) // 显示初始化界面 u8g2.drawUTF8(0, 15, &quot;等待 Volumio 数据...&quot;); u8g2.sendBuffer(); lastActiveTime = millis();&#125;SongInfo parseJsonFull(String jsonStr) &#123; SongInfo info; DynamicJsonDocument doc(2048); DeserializationError error = deserializeJson(doc, jsonStr); if (error) &#123; // 打印错误信息 info.title = &quot;数据错误&quot;; info.prevSong = &quot;未知&quot;; info.nextSong = &quot;未知&quot;; info.duration = 1; info.seek = 0; info.status = &quot;stop&quot;; return info; &#125; info.title = doc[&quot;title&quot;] | &quot;无歌曲&quot;; info.prevSong = doc[&quot;prevSong&quot;] | &quot;无&quot;; info.nextSong = doc[&quot;nextSong&quot;] | &quot;无&quot;; info.status = doc[&quot;status&quot;] | &quot;stop&quot;; info.duration = doc[&quot;duration&quot;] | 1; info.seek = doc[&quot;seek&quot;] | 0; if (info.duration &lt;= 0) info.duration = 1; if (info.seek &lt; 0) info.seek = 0; if (info.seek &gt;= info.duration) info.seek = info.duration - 1; return info;&#125;// 解析 JSON 数据SongInfo parseJson(String jsonStr) &#123; SongInfo info; DynamicJsonDocument doc(2048); DeserializationError error = deserializeJson(doc, jsonStr); if (error) &#123; info.title = &quot;数据错误&quot;; info.prevSong = &quot;未知&quot;; info.nextSong = &quot;未知&quot;; return info; &#125; // 安全提取字段 (带默认值) info.title = doc[&quot;title&quot;] | &quot;无歌曲&quot;; info.prevSong = doc[&quot;prevSong&quot;] | &quot;无&quot;; info.nextSong = doc[&quot;nextSong&quot;] | &quot;无&quot;; info.status = doc[&quot;status&quot;] | &quot;stop&quot;; info.duration = doc[&quot;duration&quot;] | 1; // 防止除零 info.seek = doc[&quot;seek&quot;] | 0; // 强制数据有效性 if (info.duration &lt;= 0) info.duration = 1; if (info.seek &lt; 0) info.seek = 0; if (info.seek &gt;= info.duration) info.seek = info.duration - 1; return info;&#125;// 安全映射函数 (防止 min==max 崩溃)int mapSafe(int value, int in_min, int in_max, int out_min, int out_max) &#123; if (in_min == in_max) return out_min; value = constrain(value, in_min, in_max); return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;&#125;// 更新 OLED 显示 (完整歌曲名，无按键提示)void updateDisplay(const SongInfo &amp;info) &#123; // 如果屏幕是关闭状态，直接返回 if (!screenOn) &#123; return; &#125; u8g2.clearBuffer(); // 1. 显示当前歌曲标题 (使用中文字体，第一行) u8g2.setFont(u8g2_font_wqy12_t_gb2312); String displayTitle = info.title; // 不进行截断，直接显示完整歌名 u8g2.drawUTF8(0, 12, displayTitle.c_str()); // 2. 显示上一首歌曲 (使用中文字体，第二行) String prevSong = &quot;前:&quot; + info.prevSong; // 不进行截断，直接显示完整歌名 u8g2.drawUTF8(0, 24, prevSong.c_str()); // 3. 显示下一首歌曲 (使用中文字体，第三行) String nextSong = &quot;后:&quot; + info.nextSong; // 不进行截断，直接显示完整歌名 u8g2.drawUTF8(0, 36, nextSong.c_str()); // 4. 绘制进度条 int progressWidth = mapSafe(info.seek, 0, info.duration, 0, 128); u8g2.drawFrame(0, 44, 128, 6); u8g2.drawBox(0, 44, progressWidth, 6); // 5. 显示时间和状态 u8g2.setFont(u8g2_font_5x7_tf); // 使用5x7小字体 char timeStr[16]; snprintf(timeStr, sizeof(timeStr), &quot;%02d:%02d/%02d:%02d&quot;, info.seek / 60, info.seek % 60, info.duration / 60, info.duration % 60); u8g2.drawStr(0, 58, timeStr); // 播放状态 (使用中文字体) u8g2.setFont(u8g2_font_wqy12_t_gb2312); String statusText = (info.status == &quot;play&quot;) ? &quot;播放&quot; : &quot;暂停&quot;; u8g2.drawUTF8(80, 58, statusText.c_str()); u8g2.sendBuffer();&#125;// 仅更新进度条和当前播放时间void updateSeekOnly(int seek, int duration) &#123; // 绘制进度条 int progressWidth = mapSafe(seek, 0, duration, 0, 128); u8g2.drawFrame(0, 44, 128, 6); u8g2.drawBox(0, 44, progressWidth, 6); // 更新时间显示 u8g2.setFont(u8g2_font_5x7_tf); // 小字体 char timeStr[16]; snprintf(timeStr, sizeof(timeStr), &quot;%02d:%02d/%02d:%02d&quot;, seek / 60, seek % 60, duration / 60, duration % 60); u8g2.drawStr(0, 58, timeStr); // 保留播放状态显示 u8g2.setFont(u8g2_font_wqy12_t_gb2312); String statusText = (lastInfo.status == &quot;play&quot;) ? &quot;播放&quot; : &quot;暂停&quot;; u8g2.drawUTF8(80, 58, statusText.c_str()); u8g2.sendBuffer();&#125;// 修改检查息屏的函数void checkScreenTimeout() &#123; unsigned long currentTime = millis(); // 如果正在播放，保持屏幕开启 if (lastInfo.status == &quot;play&quot;) &#123; if (!screenOn) turnOnScreen(); return; &#125; // 如果是暂停状态，检查是否超时 if (lastInfo.status == &quot;pause&quot; || lastInfo.status == &quot;stop&quot;) &#123; if (screenOn &amp;&amp; (currentTime - lastActiveTime &gt; SCREEN_OFF_DELAY)) &#123; turnOffScreen(); &#125; &#125;&#125;// 修改loop函数中的数据处理逻辑void loop() &#123; if (Serial.available()) &#123; String line = Serial.readStringUntil(&#x27;\\n&#x27;); line.trim(); if (line.length() &gt; 0) &#123; DynamicJsonDocument doc(2048); DeserializationError err = deserializeJson(doc, line); if (!err &amp;&amp; doc.containsKey(&quot;seek&quot;) &amp;&amp; !doc.containsKey(&quot;title&quot;)) &#123; // 进度更新 int seek = doc[&quot;seek&quot;]; updateSeekOnly(seek, lastInfo.duration); lastInfo.seek = seek; &#125; else &#123; // 完整状态更新 SongInfo newInfo = parseJsonFull(line); // 检查状态是否有重要变化 bool significantChange = (newInfo.title != lastInfo.title || newInfo.status != lastInfo.status); lastInfo = newInfo; updateDisplay(lastInfo); // 只有重要变化才重置息屏计时器 if (significantChange) &#123; lastActiveTime = millis(); &#125; &#125; &#125; &#125; // 按键操作重置息屏计时器 if (handleButtonPress()) &#123; lastActiveTime = millis(); &#125; checkScreenTimeout(); delay(50);&#125;","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"volumio运行在Q7 电视盒上","slug":"volumio-q7","date":"2025-10-31T03:48:15.000Z","updated":"2025-10-31T23:35:03.205Z","comments":true,"path":"2025/10/31/volumio-q7/","permalink":"https://pazulin.github.io/2025/10/31/volumio-q7/","excerpt":"","keywords":null,"text":"Q7 能跑一个volumio 2.8的固件地址在2.6http://updates.volumio.org/vim1/volumio/2.603/volumio-2.603-2019-09-03-vim1.img.zip 2.8http://updates.volumio.org/aml9xxxarmv7/volumio/2.857/volumio-2.857-2020-12-11-aml9xxxarmv7.img.zip 我运行是下面2.8这个版本 dtb 文件改一下, 改成一个dtb.img,这个文件我忘记是从哪里复制的了 apt 的源 要改一下deb http://archive.debian.org/debian jessie main contrib non-freedeb http://archive.debian.org/debian-security jessie&#x2F;updates main contrib non-free 下面来自恩山 PS 哪位大大 有Volumio docker ARM 版本的hub.docker.com上面找到 只有 X86 版本的N1用不了 补充一下，一、初绍化volumio 有朋友反馈无法使用以太网，需要替换DTB.img 我用的是无线，所以没有去试，那们朋友如果有回复需要替换那个文件 我再更新 42# @LXPCWL 朋友已经解决了这个问题无线初始化大概说一下，论坛里面应该有比较详细的1、写入U盘 后，启动（这个版本可以写入emmc）2、电脑（我是用笔记本，手机也可以）搜索到一个叫 volumio SSID3、连接上 查看一下获取到IP地址是不是 192.168.211.X4、访问http://192.168.211.1:30005、按照提示设置一下 volumio连接进你的家庭WIFI 二、打开ssh 访问 http://volumioIP:3000/devssh enable然后就可以 ssh登录volumio 了用户名密码都是 volumioroot 的密码也是 volumio","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"IHO-3300AD高安 刷armbian","slug":"iho-3300ad","date":"2025-10-10T05:53:02.000Z","updated":"2025-10-11T04:14:07.113Z","comments":true,"path":"2025/10/10/iho-3300ad/","permalink":"https://pazulin.github.io/2025/10/10/iho-3300ad/","excerpt":"","keywords":null,"text":"图便宜15元一个 ,买了5个 . 谁知道是高安版, 而且没有wifi . 刷机过程也是折腾 要下载一个兼容的安卓镜像, 幸运的找到一个 “小黄IHO3300AD(905)四川高安最新没有无线线刷2261.img”,如果不是,卡在1%不动 usb 公头用软件烧入, 这个步骤很奇怪, 有时候这个usb口不行,换下一个usb口就可以, 可能是我笔记本usb hub 问题? 焊好TTL先, 其中有2个跳线断开了, 2R1 2R24 短接, 恢复ttl功能. 启动进入安卓系统2r1 2r24 短接 恢复ttl功能ttl 终端 密码sh login：rootPassword：Ch4008111666 5.烧好一个armbian镜像. 发觉meson-gxl-s905l2-x7-5g.dtb 可用, 修改uEnv.txt 文件,改过来, 然后extlinux 里面 的conf文件也要把bak去掉,变成extlinux.conf,这样就能启动, 不过网卡没用要把u-boot-s905x-s905lb.bin 复制 改名为 u-boot.ext, 这样就能启动了 ,并有网卡. 插入tf卡,启动安卓, 并进入系统,执行reboot update ,就可以启动armbian 执行armbian-install . 不过安装后没有网卡, 不止什么原因,搞了很久也不想, 折腾到这里结束 Rank0: 1024MB(auto)-2T-18AddrBus test pass!-sLoad fip header from eMMC, src: 0x0000c200, des: 0x01400000, size: 0x00004000aml log : R2048 check pass!New fip structure!Load bl30 from eMMC, src: 0x00010200, des: 0x01700000, size: 0x00007600aml log : R2048 check pass!Load bl301 from eMMC, src: 0x00018200, des: 0x01700000, size: 0x00002400aml log : R2048 check pass!Load bl31 from eMMC, src: 0x0001c200, des: 0x01700000, size: 0x00019600aml log : R2048 check pass!Load bl33 from eMMC, src: 0x00038200, des: 0x01700000, size: 0x0007b000aml log : R2048 check pass!NOTICE: BL3-1: v1.0(debug):521e8c3NOTICE: BL3-1: Built : 14:22:49, Jun 5 2018NOTICE: BL31: GXL secure boot!NOTICE: BL31: BL33 decompress pass[Image: gxl_v1.1.3101-a78fa1e 2018-06-04 16:24:21 huan.biao@droid12]efuse init ops &#x3D; c5efuse init hdcp &#x3D; c, cf9&#x3D;7bl30: check_permit, count is 1bl30: check_permit: ok!chipid: 0 0 7 1c c 0 32 b4 40 a0 0 c5 not ES chip[1.633107 Inits done]INFO: BL3-1: Initializing runtime servicesWARNING: No OPTEE provided by BL2 boot loaderERROR: Error initializing runtime service opteed_fastINFO: BL3-1: Preparing for EL3 exit to normal worldINFO: BL3-1: Next image address &#x3D; 0x1000000INFO: BL3-1: Next image spsr &#x3D; 0x3c9 U-Boot 2015.01 (May 25 2021 - 14:13:05), Build: jenkins-SC_IHO-3300AD_2140133-00060-3 DRAM: 1 GiBRelocation Offset is: 36e8c000","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"编译Volumio","slug":"compile-volumio","date":"2025-09-21T11:59:23.000Z","updated":"2025-09-24T03:50:03.362Z","comments":true,"path":"2025/09/21/compile-volumio/","permalink":"https://pazulin.github.io/2025/09/21/compile-volumio/","excerpt":"","keywords":null,"text":"内存不够, 需要增加swap sudo fallocate -l 2G &#x2F;swapfile # 新建 2G 大小的 swapsudo chmod 600 &#x2F;swapfile # 权限要正确sudo mkswap &#x2F;swapfile # 格式化成 swapsudo swapon &#x2F;swapfile # 启用 swap free -h 查看 开大内存export NODE_OPTIONS&#x3D;”–max-old-space-size&#x3D;1536” 编译时减少进程npm install –unsafe-perm –no-audit –no-fund –maxsockets&#x3D;1 –verbose","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"关于在Q7的armbian里面编译8189fs驱动","slug":"ch347tdriver","date":"2024-12-13T13:59:02.000Z","updated":"2024-12-16T13:27:03.264Z","comments":true,"path":"2024/12/13/ch347tdriver/","permalink":"https://pazulin.github.io/2024/12/13/ch347tdriver/","excerpt":"","keywords":null,"text":"新版的armbian 在https://github.com/ophub/amlogic-s9xxx-armbian/releases里面,比我自己几年前编译的好多了, 但是wifi还是没有装驱动,可以手动编译一个 数码视讯的Q7的8189fs 驱动 ,注意, 必须要这个分支 12345678git clone -b rtl8189fs https://github.com/jwrdegoede/rtl8189ES_linux.git然后就是编译make -j4 ARCH=arm64 KSRC=/usr/lib/modules/$(uname -r)/buildsudo cp 8189fs.ko /usr/lib/modules/$(uname -r)/kernel/drivers/net/wireless/realtek/sudo depmod -asudo modprobe 8189fs","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"chatgpt智能音箱制作","slug":"youyou-gpt","date":"2024-12-09T13:54:21.000Z","updated":"2024-12-16T14:56:37.859Z","comments":true,"path":"2024/12/09/youyou-gpt/","permalink":"https://pazulin.github.io/2024/12/09/youyou-gpt/","excerpt":"","keywords":null,"text":"我这个armbian版本的内核比较新.6.1版本, 4.x版本也试过,没问题 先安装必要的包 如果venv没有,先安装,我的python是3.12 , 根据你版本安装 安装下面的包apt updateapt install python3.12-venvapt install python3.12-devapt install portaudio19-dev 创建虚拟环境python3 -m venv envsource env&#x2F;bin&#x2F;activate 安装包pip3 install pvporcupinepip3 install wheelpip3 install pyaudiopip3 install requestspip3 install websocket-clientpip3 install openai 因为我这个电视盒原来有个音频设备, 现在修改第二个声卡为缺省声卡, 就是用usb声卡作为缺省声卡 编辑这个文件, 如果没有创建一个&#x2F;etc&#x2F;asound.conf 123defaults.pcm.card 1defaults.pcm.device 0defaults.ctl.card 1 调整声音大小用alsamixer打开这个程序可以看到usb声卡名称, 就说明上面设置对了 安装一个可以用python i2c 驱动一个显示屏的库pip3 install luma.oled 前提是用一个CH347T做个一个usb 转i2c 的板这个板的驱动可以github上面下载编译安装.","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"Clash配置和docker使用备忘","slug":"clash","date":"2024-12-09T09:44:54.000Z","updated":"2024-12-09T10:36:59.649Z","comments":true,"path":"2024/12/09/clash/","permalink":"https://pazulin.github.io/2024/12/09/clash/","excerpt":"","keywords":null,"text":"linux下面设置环境变量包括在windows下面的bash等环境 12export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890 Docker上网桥接docker network inspect bridge ip addr show docker0你会看到一个像 172.17.0.1 的地址，这个就是 Docker 容器与主机之间的网桥地址。 步骤 2：运行 Docker 容器并配置代理你需要将容器的网络流量通过 Clash 代理，可以通过以下几种方式实现： 方法 1：在容器运行时设置环境变量运行容器时，通过环境变量设置代理： bash复制代码 123export HTTP_PROXY=http://172.17.0.1:7890export HTTPS_PROXY=http://172.17.0.1:7890export NO_PROXY=localhost,127.0.0.1 验证网络连接： 测试代理是否生效，例如： bash复制代码curl https://www.google.com 使用 Docker Volumes（卷）Docker 卷允许你将容器的数据保存在主机的文件系统上。即使容器被删除，数据仍然保留在卷中。 创建和使用卷： 1docker run -it --rm -v /path/on/host:/path/in/container node:18 bash -v &#x2F;path&#x2F;on&#x2F;host:&#x2F;path&#x2F;in&#x2F;container：这将主机的 &#x2F;path&#x2F;on&#x2F;host 目录与容器的 &#x2F;path&#x2F;in&#x2F;container 目录进行挂载。所有写入 &#x2F;path&#x2F;in&#x2F;container 的数据都会存储在主机的 &#x2F;path&#x2F;on&#x2F;host 目录中。示例： 1docker run -it --rm -v ~/mydata:/data node:18 bash 在容器中对 &#x2F;data 目录进行的所有更改都将保存在主机的 ~&#x2F;mydata 目录中，即使容器停止或删除，数据也不会丢失。","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"S905盒子安装armbian linux","slug":"s905Lbox","date":"2021-03-10T07:25:25.000Z","updated":"2021-03-10T07:33:51.293Z","comments":true,"path":"2021/03/10/s905Lbox/","permalink":"https://pazulin.github.io/2021/03/10/s905Lbox/","excerpt":"","keywords":null,"text":"过程记下来怕忘记了 打开amlogic 烧写软件, 打开Android的镜像.目前比较可行 晶晨S905L-R3300L-V21C-双直播当贝桌面-集成更多遥控适配-解决无线和直播卡顿问题-20180524版.img 这个文件, 打开烧录 靠近网口的usb (ba860盒子) 口连接到pc 短接C125 电容 (ba860盒子) 插入电源,不要松开C125 直到烧写完. ttl口接到PC,115200, 启动android. 插入我之前烧好了一个不记得什么系统的tf卡. 启动后,输入reboot update. 搞定后,可以换成armbian的系统卡.","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"中医试药体会1","slug":"try-med","date":"2021-03-05T07:45:26.000Z","updated":"2021-03-29T05:14:58.159Z","comments":true,"path":"2021/03/05/try-med/","permalink":"https://pazulin.github.io/2021/03/05/try-med/","excerpt":"","keywords":null,"text":"下针行间,太冲左右脚下针这两个穴位, 左脚下位置对一点, 太冲行针试试,第二脚趾有反应,下针位置片了一点,但是附近都又酸胀感, 右脚下不好,没什么感觉.下完后本来右协有点不舒服, 下完后确实好一点. 第二天, 左甲状腺附近的压痛感也好一些. 右甲状腺附近好一点,但是还是右压痛. 四逆散最近天气冷,手脚都冷, 感觉有点冰, 可能各种问题的原因把. 但是想单独试试四逆散, 柴胡白芍枳实甘草各6g.吃完,今天下午,手终于不想之前那么冷.脚穿袜子,鞋 ,可能不是很明显. 但没有脚很暖的感觉. 手确实是暖.另外,右边章门压痛很明显, 今天竟然不怎么压痛. 关于针灸的对侧治疗体会 之前右协不舒服,针行间, 只针行间,左脚就比右脚有感觉. 自己左胸不舒服,发现一直以来右脚的公孙位置就一直会痒,会长湿疹之类的,自己肺总有湿痰.","raw":null,"content":null,"categories":[{"name":"中医","slug":"中医","permalink":"https://pazulin.github.io/categories/%E4%B8%AD%E5%8C%BB/"}],"tags":[{"name":"中医","slug":"中医","permalink":"https://pazulin.github.io/tags/%E4%B8%AD%E5%8C%BB/"}]},{"title":"frp 内网穿越","slug":"frp","date":"2021-02-20T14:24:50.000Z","updated":"2021-02-20T14:41:25.320Z","comments":true,"path":"2021/02/20/frp/","permalink":"https://pazulin.github.io/2021/02/20/frp/","excerpt":"","keywords":null,"text":"不废话,直接上流程 服务区端mt7621的cpu的一个路由器 ,跑mipsle的程序, 客户端这个客户端时一个wr703n的路由器, 用来做mqtt server , 跑mips程序,其中把web控制页面透过frp共享出去. 端口为80 . frpc.ini 12345678910111213141516171819202122232425262728[common]server_addr = xxx.xxx.comserver_port = 7000# decide if exit program when first login failed, otherwise continuous relogin to frps# default is truelogin_fail_exit = true# auth tokentoken = xxxxxxxxxxxxx#[ssh]#type = tcp#local_ip = 127.0.0.1#local_port = 22#remote_port = 6000[tai_web]type = httplocal_port = 80privilege_mode = truecustom_domains = abc.abc.com custom_domains &#x3D; abc.abc.com 这个域名必须域名解析器加上,让其解析到 服务器ip,或者服务器的域名. 下面自启动进程 必须先安装 nohup 12opkg updateopkg install coreutils-nohup 增加下面这个文件 &#x2F;etc&#x2F;init.d&#x2F;frpc 12345678910111213#!/bin/sh /etc/rc.common# Copyright (C) 2006-2011 OpenWrt.orgSTART=99start() &#123; sleep 60; nohup /root/frp_0.35.1_linux_mips/frpc -c /root/frp_0.35.1_linux_mips/frpc.ini &gt;/tmp/nohup.out 2&gt;&amp;1 &amp;&#125;stop() &#123; kill -9 `ps | grep &#x27;/root/frp_0.35.1_linux_mips/frpc&#x27; | grep -v &#x27;grep&#x27; | awk &#x27;&#123;print $1&#125;&#x27;`&#125; 在&#x2F;etc&#x2F;rc.d&#x2F; 增加一个链接文件 ln -s &#x2F;etc&#x2F;init.d&#x2F;frpc &#x2F;etc&#x2F;rc.d&#x2F;S99frpc","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"跟施老师学经方心得","slug":"xinde","date":"2021-01-25T13:00:28.000Z","updated":"2021-01-29T16:12:31.933Z","comments":true,"path":"2021/01/25/xinde/","permalink":"https://pazulin.github.io/2021/01/25/xinde/","excerpt":"","keywords":null,"text":"缘起我少年时崇尚科学,不肖那些没有根据,玄之又玄的东西. 读书工作都是理工类, 后来偶然看到南怀瑾老师的书,为我打开一扇大门, 发现中华文化之美. 曾经想学道学庄子学佛. 中医是中华文化一部分,自然也想了解一点. 然后因为一些中医养生节目,更加激起自己兴趣, 所以2012年就自学起伤寒论. 不过各种原因, 最后放弃. 2年前,自己出现一次严重发烧胸痛,病拖了很久,一直没好,看了几个中医,有些情况好一些,有些却更糟糕. 于是索性就重新翻看以前的中医资料,找到倪老师,进而找到施老师. 于是就报名学. 未见其人,先闻其声课程开始都是网课,只听见老师声音, 但是从诊断学的头一两节课起,就觉得与我之前看那些中医视频完全不同感受. 第一次听见有人是这么解释阴阳的, 而且,老师是理工科出身, 对于我们也是学理工的人来说,真的是太对胃口了. 以前最烦那些五行生克, 觉得这些东西都是有需要的时候就挑相生的这个路径来解释 ,有时候呢,就挑相克路径来解释,都没有一个通用规则. 也许这样也有明医,但是这样对人要求太高了,要非常聪明,悟性极高之人才能学好,否则,可能就是庸医. 但是中医要传承下去, 要医病救人,总不能要求每个都是聪明绝顶的人吧? 老师的中医课程打破这些, 很少讲那些玄之又玄东西, 全都是可以看到,可以问到,可以摸到的实际表现,这让普通人,只要用功都可以学.可操作性非常强. 老师经常开玩笑,说睡不着的时候拿录音档来听,当催眠.但是我没有这种感觉,课程内容密度很大,大脑都是要开足功率来听,怎么可以当催眠? 有时候老师一股劲就在哪里说,我都没反应过来,就说完了, 经常在这种时候,老师会说:”讲得太快啊,再说一次”. 内容密度很大,经常要听一下,暂停一下然后记下来. 学药证的时候,要尝药,每一个药品都要试,体会其中的气,味. 这必然都是老师当时学习时候切身体会,觉得这样学才比较好.确实也是, 尝过药后,的确比较容易记住药的特性, 要记住一个药,如果单单文字性的东西是很难记住的,有了气味,看见实物, 五官调动起来,比较容易记住这个药,也容易联想起来. 经过诊断学,药证学,再看汤证学, 发现了一个看伤寒论汤方的全新的理解视角,以前自学的时候,看&lt;刘渡舟伤寒论讲稿&gt;,看刘老医师,胡希恕解释汤方,也许资质有限,总不能理解. 现在经过老师前面课程,再看汤证学,顿时有一感觉: 原来汤方是这样的. 结合起诊断学,药证学,理解汤方就顺理成章, 也容易记下来,也容易理解其中的加减变化原则. 对比起之前自学时候状态,真有豁然一亮之感. 想想伤寒论中的条文,不都是这种辨证论治的思路吗?不都是这些出现什么症状,给什么方,出现什么症状,加某个药或者去某个药, 老师的课程把这些都具体化,细化,系统化, 让初学者迅速入门. 历史上那么多人注解伤寒论,大多都是逐句解释, 哪有这么系统化,细化 . 将来这套东西也必然在伤寒论传承史上留下印记. 感恩国庆期间线下课, 第一次见到老师. 不知道为何, 比起讲药讲诊断, 更喜欢听老师在那里乱扯,讲故事,讲东讲西,讲修行.而且听老师讲这些时候,老是唤起我以前读南怀瑾老师书时候的一些感受. 几次想跑上去问问老师入定后是什么体会,怎么看虚云大和尚那些神奇的遭遇. 老师说把自己会都毫无保留教给我们,这点我完全相信. 就看有时候我们问问题水平能去到哪里,问题水平高,越能激发老师讲的更细更深. 最近群里面得一些练习, 让我们有难得实践机会,只有拿出来用才能真学会,就像学一门编程语言,一边用一边学 ,这样是最快学会方法. 纸上谈兵是永远学不会得. 同学不断问,老师不断回答,真的由衷感谢老师不厌其烦的耐心回答. 老师老说素食,少吃鱼肉奶蛋.听得我耳朵都起茧,听了一两次,我就改过来素食,这不很简单吗?老师怎么老说这个,对我来说青菜豆腐都可以吃得有滋有味, 原来很多人难做到,跟诊的时候一位病人诉苦,说天天素食,没有吃过一口好的. 我心里想:完蛋,病肯定好不了. 身心不一,这相佐的情绪不好, 就算病给治好,过不了多久就再犯.这就是老师口中的业力. 素食这个问题,就算自己的亲人也不会一定听你的劝谏. 对于自己病,气滞痰阻的体质,如果没有跟老师学中医,没有老师叮咛,继续原来习惯,再过几年,不知会变得怎样不可收拾. 真的很感谢老师,感谢两位这么好助教,感恩这么一班志趣相投同学, 报名跟老师学中医, 是我近年最正确的决定,没有之一. 比起适当时候买房,比起赚钱升职加薪,更让我欣喜,也许…也许是孤独的小船黑夜中看见灯塔之故.","raw":null,"content":null,"categories":[{"name":"中医","slug":"中医","permalink":"https://pazulin.github.io/categories/%E4%B8%AD%E5%8C%BB/"}],"tags":[{"name":"中医","slug":"中医","permalink":"https://pazulin.github.io/tags/%E4%B8%AD%E5%8C%BB/"}]},{"title":"神迹","slug":"shenji1","date":"2020-12-24T08:47:22.000Z","updated":"2020-12-24T08:49:02.102Z","comments":true,"path":"2020/12/24/shenji1/","permalink":"https://pazulin.github.io/2020/12/24/shenji1/","excerpt":"","keywords":null,"text":"神迹东势王朝倒塌后第三天，救难人员从扭曲变形的钢筋水泥中，救出钟永祥先生，被困数十个小时，重见天日的那一刻，他不仅神情镇定，身体状况仍十分良好;更令人惊讶的是：他并没有灰头土脸，甚至还可以称得上是相当“干净”!钟先生被救出后，他告诉大家一段遭遇，这件事传出后，众人莫不啧啧称奇。 故事得从钟先生一位远亲来访谈起。钟先生是广东人，他的亲戚远道来台探亲，身为主人的，当然热情款待。几天后，远亲整装离台，临行前，除了感谢之外，还特别告诉钟先生：“你们家的客房很清凉，睡起来好舒服，有时你也可以睡睡看。” 钟先生平常都睡在主卧室，那天钟太太到台中看儿子，他想起远亲的那番话，于是当晚便改睡在客房。 睡眠正甜时，突然大地一阵撼动。钟先生家住六楼，他感觉家里似乎向下坠落，真乎?梦乎?房屋四壁好像被什么东西挤压，就快碎裂般。 可是刹那间，他看见好几个全身散发金色、而且光头的人，用手撑住他头顶上那片即将倾倒的墙，同时，又有几个人压在他身上，感觉好像是在护著他的身体一般。 他心想：“三更半夜，为什么有这么多人在我房间?”猛然回神，发现四处漆黑，他问：“你们是什么人?”用手挥动，却发现杳无人迹。 这时，他摸摸身旁，吓了一跳，墙壁倾斜，他正处在中间的小空隙中。由于平日笃信佛法，钟先生马上想到：“刚刚一定是菩萨来救我!”于是端坐起来，就在墙与地之间的小缝中专心念佛。 三天过去，如果一般人陷于瓦砾中，必定觉得度日如年，身心逼恼。但是钟先生说：“我只有一心念佛、念观世音菩萨的名号，全然不管身在何处，反倒觉得自己很快就被救出来了。” 被救出后，钟先生才知道，东势王朝五楼以下陷落坍平，六楼变成一楼，而他家除了客房一角仍有空隙外，其他房间早已挤成一团。 同样是东势灾民的刘春珠师姐听说钟先生的事迹后，她特地去拜访。之前，她就风闻钟先生为人乐善好施，是一位医术高明的中医师，也专精针灸，平常若有贫穷患者求诊，他就分文不收。 刘师姐到钟先生的诊所，说明来意，钟先生知道她也是佛弟子，就告诉她更多奇迹。钟先生的诊所是一栋四楼建筑，四楼是佛堂，供奉三尊佛像，有释迦世尊及观世音菩萨，都是瓷器所造。地震后，佛像震落地上，不可思议，竟完好如初。 一、二、三楼都有书柜，奇特的事情发生了。钟先生行医多年，略有积蓄，在两岸开放探亲后，他重返广东故居，听人说某古寺倾倒荒废，他便独力资助寺院重建，此寺名为“绵洋寺”(位于福建省)。寺院落成时，他拍了许多照片当做纪念，这些照片就分别贴在书柜的玻璃上。 钟先生告诉刘师姐：“所有书柜材质一模一样，地震时所有的书柜倒了一地，但是，只要是贴著绵洋寺照片的柜子，完全没事，其他的柜子，玻璃碎落一地。” 这次大地震，钟永祥先生见证了佛菩萨的神迹，他说：感谢佛菩萨保佑，今后要更努力行善!","raw":null,"content":null,"categories":[{"name":"寓言","slug":"寓言","permalink":"https://pazulin.github.io/categories/%E5%AF%93%E8%A8%80/"}],"tags":[{"name":"寓言","slug":"寓言","permalink":"https://pazulin.github.io/tags/%E5%AF%93%E8%A8%80/"}]},{"title":"寓言","slug":"story-shy","date":"2020-12-10T14:30:02.000Z","updated":"2020-12-10T15:20:24.465Z","comments":true,"path":"2020/12/10/story-shy/","permalink":"https://pazulin.github.io/2020/12/10/story-shy/","excerpt":"","keywords":null,"text":"来自 http://loveheal.org/phpbb3/viewforum.php?f=6 馬雅（Maya）的奧秘 ～這是一個印度的神話，寓意深遠。這是一個印度的神話。那拉達是一位專司音樂的半仙，祂愛管閒事，喜歡到處旅行，替天界的神明傳閒話。 那拉達急於知道毘濕努神（Vishinu）的「馬雅」奧秘，於是祂來到昆濕努神歇息的樹林中。打過招呼之後，那拉達詢問這位象徵藍色大海的神祇有關祂的馬雅奧祕。『馬雅』指的是蒙蔽世人的幻覺之王。 昆濕努神答應告訴那拉達這個奧祕，但是祂覺得口渴，祂希望那拉達能替他取點水來喝。那拉達進入森林想找一個有水的人家。過了不久祂來到一棟房子面前。祂敲了敲門，一位非常美麗的少女前來開門。她面帶微笑，用她那對如蓮的大眼看著祂，接著就轉過身去取水。那拉達迷上了這位少女，祂在牠的家中一待就是好幾天。 時間很快便過去了，那拉達和祂所愛的人結成夫妻，並且生了幾個小孩。那拉達和妻小生活得非常快樂。有一年大雨下個不停，洪水淹沒了兩岸，沖走了那拉達的家和附近的樹木。祂一手抓著妻子，一手抓著孩子，肩膀上還扛著另一個小孩。那拉達涉水尋找躲避的高地，但是不久洪水就淹沒了祂的胸膛和下巴。祂的孩子一個一個被洪水沖走，只有妻子還在身邊。黑夜的來臨更增加了祂心中的恐懼，洪水仍然繼繽高漲，最後祂的妻子也抓不住祂，被洪水淹沒。在孤單無助的情況下，祂舉起雙手向神明求援，突然有一個聲音從空中傳來：「十分鐘已經過去了，我的那杯水到底在哪裏啊？」 編者註： 馬雅（Maya）在佛教的語言中，就是由眾生共業所交織而成的業力。 在我們中國的道家哲理故事中，也有同樣的故事；例如「黃梁一夢」與「南柯一夢」的故事都有相同的寓意。 在我們的一生將要結束的最後一刻，希望你可以想起這個充滿智慧的故事。 一袋寶石～蘇菲教派的寓言故事～早上一大早，太陽還沒有出來，一個漁夫到了河邊，在岸上他感覺到有什麼東西在他的腳下，後來找出來是一小袋的石頭。他撿起袋子，將漁網放在一旁，坐在岸邊等待日出。 他在等待黎明，以便開始一天的工作，他懶洋洋地從袋子裡拿出一塊石頭丟進水裡。沒有其他事可做，他繼續把石頭一塊一塊丟進水裡。 慢慢地，太陽升起，大地重現光明，這時除了一塊石頭之外其他的石頭都丟光了，最後一塊石頭在他的手裡。當他藉著白天的光看到了他手中所拿的東酉時，他的心跳幾乎都要停止了，那是一顆寶石！在黑暗中，他把整裝的寶石都丟光了！在不知不覺當中，他的損失有多少！他充滿懊悔，咒罵他自己，很傷心地哭得幾乎失去理智。 他在無意間碰到的財富足夠豐富他的生活好幾倍，然而在不知不覺當中，在黑暗中，他又把它丟掉了。但是就某方面來講，他還是幸運的﹍還有一顆寶石留下來，在他將那顆寶石丟掉之前，天己經亮了。一般來講，大多數的人甚至還沒有那麼幸運。 周圍一片漆黑，而時間又過得很快，太陽尚未升起我們就己經浪費掉所有生命中的寶石。生命是一個大的寶庫，人類沒有好好利用它，只是白白地將它浪費掉，等到我們知道了生命的重要性時，我們已經將時光消磨殆盡。生活的秘密、奧秘、快樂、解脫、慈悲、智慧……，一切都丟盡了，而一個人的一生就這樣過去了。 抓猴子的方法抓猴子的方法 有一隻猴子在樹上玩耍嬉戲，突然，牠看到了樹下有一個看起來很好吃的櫻桃，於是牠就從樹上下來，牠發現了這個櫻桃是在一個很大的玻璃瓶裡面。 這個玻璃平的瓶口很窄小，恰好猴子的手可以伸進去，於是猴子用手伸進去抓住了這個好吃的櫻桃，可是牠的手因為握住了櫻桃，所以沒有辦法從窄小的瓶口伸出來。 此時獵人從遠處從容地走過來，猴子還是不知道應該把手中的櫻桃放開，於是就被獵人給抓住了。 附註：我們是不是也常常為了眼前小小的利益，忘了人生更重要的目標呢？ 莊嚴的寺廟～美的奧秘～有一個皇帝想要整修在京城裡的一座寺廟，他派人去找技藝高超的設計師，希望能夠將寺廟整修成美麗而又莊嚴。 後來有兩組人員被找來了，其中一組是京城裡很有名的工匠與畫師，另外一組是幾個和尚。由於皇帝沒有辦法決定到底哪一組人員的的手藝比較好，於是他就決定要給他們機會作一個比較。 皇帝要求這兩組人員，各自去整修一個小寺廟，而這兩個寺廟互相面對面；三天之後，皇帝要來驗收成果。 工匠們向皇帝要了一百多種顏色的顏料（漆），又要求了很多的工具；而讓皇帝很奇怪的是，和尚們居然只要了一些抹布與水桶等等簡單的清潔用具。 三天之後，皇帝來驗收兩組人員裝修寺廟的結果，他首先看看工匠們所裝飾的寺廟，工匠們敲鑼打鼓地慶祝著工程的完成，他們用了非常多的顏料，以非常精巧的手藝把寺廟裝飾得五顏六色。皇帝很滿意地點點頭，接著回過頭來看看和尚們負責整修的寺廟，他一看之下就愣住了，和尚們所整修的寺廟沒有塗上任何的顏料，他們只是把所有的牆壁、桌椅、窗戶等等都擦拭的非常乾淨，寺廟中所有的物品都顯現出了它們原來的顏色，而它們光澤的表面就像鏡子一般，無瑕地反射出從外面而來的色彩，那天邊多變的雲彩、隨風搖曳的樹影，甚至是對面五顏六色的寺廟，都變成了這個寺廟美麗色彩的一部份，而這座寺廟只是寧靜地接受這一切。 皇帝被這莊嚴的寺廟深深地感動了，當然我們也知道最後的勝負了。 筆者註：我們的心就像是一座寺廟，我們不需要用各種精巧的裝飾來美化我們的心靈，我們需要的只是讓內在原有的美，無瑕地顯現出來。 慾望的鎖鍊～發生在我們周遭的故事～有一位禁欲苦行的修道者，準備離開他所住的村莊，到無人居住的山中去隱居修行，他只帶了一塊布當作衣服，就一個人到山中居住了。 後來他想到當他要洗衣服的時候，他需要另外一塊布來替換，於是他就下山到村莊中，向村民們乞討一塊布當作衣服，村民們都知道他是虔誠的修道者，於是毫不考慮地就給了他一塊布，當作換洗用的衣服。 當這位修道者回到山中之後，他發覺在他居住的茅屋裡面有一隻老鼠，常常會在他專心打坐的時候來咬他那件準備換洗的衣服，他早就發誓一生遵守不殺生的戒律，因此他不願意去傷害那隻老鼠，但是他又沒有辦法趕走那隻老鼠，所以他回到村莊中，向村民要一隻貓來飼養。 得到了一隻貓之後，他又想到了─『貓要吃什麼呢？我並不想讓貓去吃老鼠，但總不能跟我一樣只吃一些水果與野菜吧！』，於是他又向村民要了一隻乳牛，這樣子那隻貓就可以靠牛奶維生。 但是，在山中居住了一段時間以後，他發覺每天都要花很多的時間來照顧那隻母牛，於是他又回到村莊中，他找到了一個可憐流浪漢，於是就帶這無家可歸的流浪漢到山中居住，幫他照顧乳牛。 那個流浪漢在山中居住了一段時間之後，他跟修道者抱怨說：「我跟你不一樣，我需要一個太太，我要正常的家庭生活。」修道者想一想也是有道理，他不能強迫別人一定要跟他一樣，過著禁欲苦行的生活………. 這個故事就這樣繼續演變下去，你可能也猜到了，到了後來，也許是半年以後，整個村莊都搬到山上去了。","raw":null,"content":null,"categories":[{"name":"寓言","slug":"寓言","permalink":"https://pazulin.github.io/categories/%E5%AF%93%E8%A8%80/"}],"tags":[{"name":"寓言","slug":"寓言","permalink":"https://pazulin.github.io/tags/%E5%AF%93%E8%A8%80/"}]},{"title":"中医一些观点","slug":"learntm","date":"2020-12-04T09:39:25.000Z","updated":"2020-12-07T08:25:36.401Z","comments":true,"path":"2020/12/04/learntm/","permalink":"https://pazulin.github.io/2020/12/04/learntm/","excerpt":"","keywords":null,"text":"下面这些内容来自 http://loveheal.org/ 我的老师施合一. 我引用过来是怕自己忘记了. 关于糖中醫觀點：請大家到原來引用的網址去看這位女士的圖片，的確臉色變亮了（也許有人會說臉色可以用修圖軟體改變）、眼袋明顯縮小了。中醫認為，飲食方面應該五味均衡、清淡，不宜偏重一味；但現代人常常太偏重辛辣、或甜味、或酸甜，偏重各種口味都會有不同的副作用，以後會再說明。此處只討論甜味(中醫稱為甘味)，天然的甜味，例如甘蔗汁，可以潤肺養脾胃，曾經有一位初期糖尿病患的女患者，因為其他不舒服症狀來看診，她檢查到有血糖過高、有糖尿病的時候，她聽說甘蔗汁可以治療消渴證，於是每天喝甘蔗汁一個月(每天喝的量我忘記了，抱歉..)，各位讀者猜結果如何？結果一個月後血糖下降，真的糖尿病症狀改善了。如果各位讀者每天吃精製糖、白糖做成的甜點、甜的飲料等等，請問是否糖尿病症狀會改善？答案是否定的，應該會加重，而且會有容易胃酸過多、脂肪堆積等等問題產生。為什麼甘蔗汁、天然的紅糖與精製糖不一樣呢？天然的甘蔗汁帶有一點酸澀的味道是白糖沒有的，而酸澀的味道是養陰的，這就是甘蔗汁與精製白糖的不同。所以筆者才會提倡，如果要吃甜味的食物或飲料，請確認要用天然的甘蔗汁、或天然紅糖、黑糖、天然蜂蜜等。不過，天然的甜味也不是吃越多越好；首先，中醫認為甘能令人中滿，吃太甜，容易有胃部脹滿、胃酸過多的問題；其次，甘味能益脾陽，但脾陽過亢則容易損傷脾陰，例如小孩子甜食吃多會亢奮、過動，這是陽太亢的現象，而大人甜食吃多，會導致容易口渴、餓的時候氣虛乏力的消渴現象，這是第二個問題；第三，吃太甜容易在體內累積濕氣，導致脂肪堆積、身體沈重、血脈運行不暢等問題；第四，甜的食物或飲料吃太多，脾土過亢則剋腎水，使得小孩子可能過動之外，也容易骨骼發育不良，腦部發育遲緩，家長不可不慎。結論就是，天然的甜味食物，適量有益於健康，但過量則不宜。至於精製糖、人工糖、果糖、化學糖精等等，就盡量避免；否則就可能導致糖尿病、胃酸過多、火燒心、過動、發育遲緩、智力減退等問題。","raw":null,"content":null,"categories":[{"name":"中医","slug":"中医","permalink":"https://pazulin.github.io/categories/%E4%B8%AD%E5%8C%BB/"}],"tags":[{"name":"中医","slug":"中医","permalink":"https://pazulin.github.io/tags/%E4%B8%AD%E5%8C%BB/"}]},{"title":"小河流的旅程","slug":"river","date":"2020-09-27T07:51:54.000Z","updated":"2020-09-27T08:07:02.777Z","comments":true,"path":"2020/09/27/river/","permalink":"https://pazulin.github.io/2020/09/27/river/","excerpt":"","keywords":null,"text":"来自 http://loveheal.org/phpbb3/viewtopic.php?f=6&amp;t=7 小河流的旅程 有一條小河流從遙遠的高山上流下來，經過了很多個村莊與森林，最後它來到了一個沙漠。它想：「我已經越過了重重的障礙，這次應該也可以越過這個沙漠吧！」 當它決定越過這個沙漠的時候，它發現它的河水漸漸消失在泥沙當中，它試了一次又一次，總是徒勞無功，於是它灰心了，「也許這就是我的命運了，我永遠也到不了傳說中那個浩瀚的大海。」它頹喪地自言自語。 這時候，四周響起了一陣低沈的聲音，「如果微風可以跨越沙漠，那麼河流也可以。」原來這是沙漠發出的聲音。 小河流很不服氣地回答說：「那是因為微風可以飛過沙漠，可是我卻不行。」 「因為你堅持你原來的樣子，所以你永遠無法跨越這個沙漠。你必須讓微風帶著你飛過這個沙漠，到你的目的地。只要願意你放棄你現在的樣子，讓自己蒸發到微風中。」沙漠用它低沈的聲音這麼說。 小河流從來不知道有這樣的事情，「放棄我現在的樣子，然後消失在微風中？不！不！」小河流無法接受這樣的概念，畢竟它從未有這樣的經驗，叫它放棄自己現在的樣子，那麼不等於是自我毀滅了嗎？「我怎麼知道這是真的？」小河流這麼問。 「微風可以把水氣包含在它之中，然後飄過沙漠，到了適當的地點，它就把這些水氣釋放出來，於是就變成了雨水。然後這些雨水又會形成河流，繼續向前進。」沙漠很有耐心地回答。 「那我還是原來的河流嗎？」小河流問。 「可以說是，也可以說不是。」沙漠回答。「不管你是一條河流或是看不見的水蒸氣，你內在的本質從來沒有改變。你會堅持你是一條河流，是因為你從來不知道自己內在的本質。」 此時小河流的心中，隱隱約約地想起了似乎自己在變成河流之前，似乎也是由微風帶著自己，飛到內陸某座高山的半山腰，然後變成雨水落下，才變成今日的河流。 於是小河流終於鼓起勇氣，投入微風張開的雙臂，消失在微風之中，讓微風帶著它，奔向它生命中（某個階段）的歸宿。 附註： 我們的生命歷程往往也像小河流一樣，想要跨越生命中的障礙，達成某種程度的突破，往真善美的目標邁進，也需要有「放下自我」的勇氣，邁向未知的領域。 2012&#x2F;12&#x2F;09 後記：這個故事是我在十幾年前從一本英文書中翻譯成中文的，今日一時興起，在GOOGLE搜尋了一下，沒想到可以得到24萬筆以上的結果；還被遠流出版社出版過。有佛教、天主教、基督教的網站引用，甚至熱烈討論，當然也有些傳銷業者等等的使用。但是他們可能都不知道，這是一個回教蘇菲教派的寓言故事，用來揭示一些修行的真理。我相信有些宗教人士，一旦知道這是源自回教的故事，就會心生芥蒂，他們看這個故事的感覺就變了….其實真理一直在那邊，但是我們凡夫的眼光有限，只能用自己的小我來認知，每個人、每個宗教都只能認知一部份，如今一些極端宗教人士，為了強調自己所信仰宗教的崇高、唯一性，卻要去貶抑、甚至仇視其他宗教，在我看來，這些都是因為人們沒將心眼打開、無法看到無所不在的愛，所以被自己的我執所限制，才有這些分裂與誤解，甚至衍生成仇恨與殺戮。可嘆..","raw":null,"content":null,"categories":[{"name":"寓言","slug":"寓言","permalink":"https://pazulin.github.io/categories/%E5%AF%93%E8%A8%80/"}],"tags":[{"name":"寓言","slug":"寓言","permalink":"https://pazulin.github.io/tags/%E5%AF%93%E8%A8%80/"}]},{"title":"armbian跑AI网络-Yolo做识别的尝试","slug":"yolo-test1","date":"2020-08-19T06:55:20.000Z","updated":"2023-01-16T03:04:28.422Z","comments":true,"path":"2020/08/19/yolo-test1/","permalink":"https://pazulin.github.io/2020/08/19/yolo-test1/","excerpt":"","keywords":null,"text":"这个板子是8核A53的amlogic 的S912 . 不过我看过对比，比起A72的新的树莓4，还是差很多，平均1个A72&#x3D;4个A53. 树莓4有4个A72. 树莓4才有0.1T的计算力。 这样算，这个才有0.05T个算力。 过程写一下。 准备‘’’sudo apt-get install python-opencvsudo apt-get install python-pipsudo pip install –upgrade git+https://github.com/Maratyszcza/PeachPysudo pip install –upgrade git+https://github.com/Maratyszcza/confu‘’’ 这个过程会出错，说少这个少那个， 看见少的就安装，用apt install xxxx比如少 No module named ‘setuptools’少wheel 必须安装下面这个,到底有什么用,不知道,会不会和下面这个重复,不清楚,反正我之前没下载, 后面这个反复编译都出错‘’’sudo apt-get install ninja-build‘’’ 安装编译器,这个过程会下载很多依赖库,可能会出错,出错重新来, 12345git clone https://github.com/ninja-build/ninja.gitcd ninjagit checkout release./configure.py --bootstrapexport NINJA_PATH=$PWD 下载编译nnpack 12345678910git clone https://github.com/shizukachan/NNPACKcd NNPACKconfu setuppython ./configure.py --backend auto$NINJA_PATH/ninjasudo cp -a lib/* /usr/lib/sudo cp include/nnpack.h /usr/include/sudo cp deps/pthreadpool/include/pthreadpool.h /usr/include/ 上面经常出错,可以利用cmake来做 1234mkdir buildcd buildcmake -G Ninja ..ninja 然后手动把编译出来的库复制到系统目录 &#x2F;usr&#x2F;lib&#x2F; , 还有下面的h文件 12sudo cp include/nnpack.h /usr/include/sudo cp deps/pthreadpool/include/pthreadpool.h /usr/include/ 下载编译darknet 1234git clone -b yolov3 https://github.com/zxzhaixiang/darknet-nnpackcd darknet-nnpackgit checkout yolov3make 测试 ,运行python rpi_video.py 不过我得是usb接口摄像头, 要修过,用图片测试是ok得.","raw":null,"content":null,"categories":[{"name":"AI","slug":"AI","permalink":"https://pazulin.github.io/categories/AI/"}],"tags":[{"name":"AI armbian","slug":"AI-armbian","permalink":"https://pazulin.github.io/tags/AI-armbian/"}]},{"title":"armbian 阿里云源地址","slug":"aliyun-port-addr","date":"2020-08-17T08:36:30.000Z","updated":"2020-08-17T08:37:57.616Z","comments":true,"path":"2020/08/17/aliyun-port-addr/","permalink":"https://pazulin.github.io/2020/08/17/aliyun-port-addr/","excerpt":"","keywords":null,"text":"&#x2F;etc&#x2F;apt&#x2F;source.list 1234567891011deb http://mirrors.aliyun.com/ubuntu-ports/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu-ports/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu-ports/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu-ports/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu-ports/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu-ports/ bionic-backports main restricted universe multiverse","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"心悸-桂枝甘草汤体验","slug":"guizhi1","date":"2020-07-31T08:56:34.000Z","updated":"2020-07-31T09:15:25.153Z","comments":true,"path":"2020/07/31/guizhi1/","permalink":"https://pazulin.github.io/2020/07/31/guizhi1/","excerpt":"","keywords":null,"text":"最近不知道何故，可能是出大汗的原因，出汗时都感觉到心悸，心痛。然后，非常明显几天之内，出现经常心悸情况，就是心跳很快，很不正常，心很不舒服，下午3-5点先是脚趾感觉到冷，一天后同样时间段，感觉到连手指都冷。完蛋，心脏出大问题， 一睡觉心悸得根本睡不着，整个晚上失眠。睡着就是心悸醒，然后竟然左右手麻，开始是左手，一天后连右手也是，心想完蛋，是不是快死的节奏。 学中医功力还不够，不知道怎么处理，之前晚上有时候醒来也发现有心悸情况，本来以为是身体有痰有湿堵住，心跳加速来补偿身体需要。怎么发现几天之内情况急速恶化。吓死了，以为真的就这么大。 想到之听到的奔豚的现象的时候，有桂枝加桂汤，看了有类似的汤剂。发现桂枝甘草汤就是处理这个心阳虚， 1234桂枝 甘草条辩：发汗过多，其人叉手自冒心，心下悸，欲得按者。 欲按，虚证。 于是我买肉桂，应该是紫油桂，算比较好，真如老师（施合一）所说的，气没有食品那些肉桂那么香，但是反而更适合走里。 于是打粉。先煮了一些炙甘草，然后配合几克肉桂粉。 然后，晚上睡觉，很好，没有心悸，而且很久没有睡的那么深沉。神效。 能得这个病，肯定心脏也不怎么健康了。再观察吧。","raw":null,"content":null,"categories":[{"name":"中医","slug":"中医","permalink":"https://pazulin.github.io/categories/%E4%B8%AD%E5%8C%BB/"}],"tags":[{"name":"中医 经方","slug":"中医-经方","permalink":"https://pazulin.github.io/tags/%E4%B8%AD%E5%8C%BB-%E7%BB%8F%E6%96%B9/"}]},{"title":"armbian定时播放mp3","slug":"cron-play-mp3","date":"2020-01-07T06:57:20.000Z","updated":"2023-04-30T10:56:44.257Z","comments":true,"path":"2020/01/07/cron-play-mp3/","permalink":"https://pazulin.github.io/2020/01/07/cron-play-mp3/","excerpt":"","keywords":null,"text":"为了小孩多听粤语,想播放以前收音机里面的小说节目,于是做了一个这样的东西, 每天定时大约吃饭时间播放一集节目, 第一季节目就播三国演义把. 垃圾电视盒刷armbian, 接usb 声卡, 一个功放模块,一个控制模块, 三个模块都是自己做了, 控制模块是usb转串口,接一个单片机,控制功放模块的电源, 因为24小时不停待机,因此不播放的时候要休眠状态.垃圾电视盒是没有IO的,所以有这个东西. 安装所有必须的东西samba, cifs-utils , 音频文件在nas上,所以要装samba 共享.stty,控制串口波特率等sox , 播放mp3的的东西apt-get install libsox-fmt-all 支持mp3python, 控制脚本 python 脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/pythonimport jsonimport osimport linecacheimport sysfilename = &#x27;cur_play_id.json&#x27;list_name = &#x27;play_list&#x27;index=1os.system(&#x27;stty -F /dev/ttyUSB0 115200&#x27;)os.system (&#x27;echo &quot;:9000020101aa\\r\\n&quot; &gt;&gt; /dev/ttyUSB0&#x27;)os.system (&#x27;play sanya.mp3&#x27;)if len(sys.argv) &gt; 1 : list_name= sys.argv[1] print(list_name)try: with open (filename) as f_obj: ja=json.load(f_obj) index=ja[&#x27;cur_index&#x27;] index = index +1except FileNotFoundError: print(&quot;index file Not Found!@!!!&quot;) index = 1try: play_file = linecache.getline(list_name,index).strip() if play_file ==&#x27;&#x27; : print (&quot;end of play list file&quot;) else : a_cmd = &#x27;play &#x27; + play_file print(a_cmd) os.system(a_cmd) os.system (&#x27;echo &quot;:9000020100aa\\r\\n&quot; &gt;&gt; /dev/ttyUSB0&#x27;)except FileNotFoundError: print (&quot;Play List file not found!!&quot;) os._exit(0)data_dic = &#123;&#x27;cur_index&#x27;:index&#125;with open(filename,&#x27;w&#x27;) as f: json.dump(data_dic,f) 用法就是python play_mp3.py list.txt 生成播放列表文件的脚本 1ls -1 |awk &#x27;&#123;print i$0&#125;&#x27; i=`pwd`&#x27;/&#x27; &gt; list.txt","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"linux 默认声卡设置","slug":"armbian-default-sound-card","date":"2019-12-06T04:03:35.000Z","updated":"2019-12-06T04:31:43.757Z","comments":true,"path":"2019/12/06/armbian-default-sound-card/","permalink":"https://pazulin.github.io/2019/12/06/armbian-default-sound-card/","excerpt":"","keywords":null,"text":"下面是修改第二个声卡为缺省声卡 &#x2F;etc&#x2F;asound.conf 123defaults.pcm.card 1defaults.pcm.device 0defaults.ctl.card 1","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"随笔","slug":"sui1","date":"2019-11-21T03:37:09.000Z","updated":"2020-01-07T07:07:54.354Z","comments":true,"path":"2019/11/21/sui1/","permalink":"https://pazulin.github.io/2019/11/21/sui1/","excerpt":"","keywords":null,"text":"","raw":null,"content":null,"categories":[{"name":"live","slug":"live","permalink":"https://pazulin.github.io/categories/live/"}],"tags":[{"name":"live","slug":"live","permalink":"https://pazulin.github.io/tags/live/"}]},{"title":"905盒子装armbian后基本设置","slug":"armbian-mac","date":"2019-10-31T07:19:40.000Z","updated":"2019-10-31T07:38:01.333Z","comments":true,"path":"2019/10/31/armbian-mac/","permalink":"https://pazulin.github.io/2019/10/31/armbian-mac/","excerpt":"","keywords":null,"text":"#设置mac 盒子mac 没有,直接编辑 &#x2F;etc&#x2F;network&#x2F;interfaces 文件，在 iface eth0 inet static 后面添加一行：pre-up ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx（要改成的MAC） 12345iface eth0 inet staticpre-up ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx（要改成的MAC）address 192.168.1.10netmask 255.255.255.0gateway 192.168.1.1 对于wifi 也是一样 另外一种说法 uboot 中设置,不过我试过不行 &#x2F;boot&#x2F;uEnv.ini dtb_name&#x3D;&#x2F;dtb&#x2F;meson-gxl-s905d-phicomm-n1.dtbbootargs&#x3D;root&#x3D;LABEL&#x3D;ROOT_EMMC rootflags&#x3D;data&#x3D;writeback rw console&#x3D;ttyAML0,115200n8 console&#x3D;tty0 no_cons…………………..ethaddr&#x3D;42:b8:79:09:d8:ed #设置时区 1echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #设置语言环境&#x2F;etc&#x2F;environment 123ARCH=arm64LC_ALL=&quot;en_US.UTF-8&quot;LANG=&quot;en_US.UTF-8&quot;","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"add rtl8189fs driver for armbian","slug":"add-rtl8189fs-driver-armbian","date":"2019-10-22T10:17:20.000Z","updated":"2019-10-22T10:35:47.884Z","comments":true,"path":"2019/10/22/add-rtl8189fs-driver-armbian/","permalink":"https://pazulin.github.io/2019/10/22/add-rtl8189fs-driver-armbian/","excerpt":"","keywords":null,"text":"数码视讯Q7 的垃圾电视盒30元一个,S905L芯片, A53 x 4 ,1G RAM , 可以跑很多东西,本来想跑一些nas应用,后来猫盘,什么我家云等矿渣也不断出来,就放弃, 现在计划拿来跑AI的一些视频识别应用. armbian 上面针对S905的都没有rtl8189的驱动,那就自己加 下载virtul box, 在上面跑一个unbutu的虚拟机,这里必须用官方mini.iso来安装.不能用18.4.3 这个官方推荐版本,说来都是泪,说白了就是版本依赖的问题. 下载armbian build脚本,我们用150balbes 针对s905的版本 123git clone https://github.com/150balbes/Build-Armbiancd Build-Armbian./compile.sh BOARD=aml-g12 BRANCH=default RELEASE=bionic BUILD_MINIMAL=no BUILD_DESKTOP=no KERNEL_ONLY=no KERNEL_CONFIGURE=yes 下面这段话是别人的 1234567BOARD 设置为 aml-g12，可以选 aml-s905，但是只有 aml-g12 编译时用的源码是最新的BRANCH 编译使用的源码分支 在 105 的 build 中，default 使用的是他自己 fork 的 S905 kernel 源码RELEASE 为需要编译的版本，我这里设置为 Ubuntu 19.04 disco，可以选择 buster bionic stretch xenial 等BUILD_MINIMAL 是否为最小版本，这个选项改为 yes 之后，没有 armbian-config 了，所以还是把它改为了 noBUILD_DESKTOP 是否编译桌面版本KERNEL_ONLY 是否只编译内核KERNEL_CONFIGURE 是否在开始编译是打开内核配置，这个选项需要设置为 yes，来添加我们需要的 WIFI 驱动 修改 &#x2F;Build-Armbian&#x2F;lib&#x2F;compilation-prepare.sh 脚本 增加下载编译rtl8189的代码代码在这里 https://github.com/jwrdegoede/rtl8189ES_linux 123456789101112131415161718192021222324252627282930# Wireless drivers for Realtek 8189ES chipsetsif linux-version compare $version ge 3.14 &amp;&amp; [ &quot;$EXTRAWIFI&quot; == yes ]; then # attach to specifics tag or branch local rtl8189es=&quot;branch:rtl8189fs&quot; #必须用这个分支 display_alert &quot;Adding&quot; &quot;Wireless drivers for Realtek 8189fs chipsets $&#123;rtl8189es&#125;&quot; &quot;info&quot; fetch_from_repo &quot;https://github.com/jwrdegoede/rtl8189ES_linux&quot; &quot;rtl8189fs&quot; &quot;$&#123;rtl8189es&#125;&quot; &quot;yes&quot; cd $&#123;SRC&#125;/cache/sources/$&#123;LINUXSOURCEDIR&#125; rm -rf $&#123;SRC&#125;/cache/sources/$&#123;LINUXSOURCEDIR&#125;/drivers/net/wireless/rtl8189fs mkdir -p $&#123;SRC&#125;/cache/sources/$&#123;LINUXSOURCEDIR&#125;/drivers/net/wireless/rtl8189fs/ cp -R $&#123;SRC&#125;/cache/sources/rtl8189fs/$&#123;rtl8189es#*:&#125;/&#123;core,hal,include,os_dep,platform&#125; \\ $&#123;SRC&#125;/cache/sources/$&#123;LINUXSOURCEDIR&#125;/drivers/net/wireless/rtl8189fs # Makefile cp $&#123;SRC&#125;/cache/sources/rtl8189fs/$&#123;rtl8189es#*:&#125;/Makefile \\ $&#123;SRC&#125;/cache/sources/$&#123;LINUXSOURCEDIR&#125;/drivers/net/wireless/rtl8189fs/Makefile cp $&#123;SRC&#125;/cache/sources/rtl8189fs/$&#123;rtl8189es#*:&#125;/Kconfig \\ $&#123;SRC&#125;/cache/sources/$&#123;LINUXSOURCEDIR&#125;/drivers/net/wireless/rtl8189fs/Kconfig # Add to section Makefile echo &quot;obj-\\$(CONFIG_RTL8189FS) += rtl8189fs/&quot; &gt;&gt; $SRC/cache/sources/$&#123;LINUXSOURCEDIR&#125;/drivers/net/wireless/Makefile sed -i &#x27;/source &quot;drivers\\/net\\/wireless\\/ti\\/Kconfig&quot;/a source &quot;drivers\\/net\\/wireless\\/rtl8189fs\\/Kconfig&quot;&#x27; \\ $SRC/cache/sources/$&#123;LINUXSOURCEDIR&#125;/drivers/net/wireless/Kconfigfi 然后就重新编译就可以, 上面看上去好像很简单,我也搞了几天. 下面这段事别人的, https://blog.csdn.net/jklinux/article/details/78737691 我复制过来, 有时候有用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153通过检查电路原理图，可以发现此wifi芯片是连接到板上mmc1控制器上的。H5共有三个sd/mmc控制器, 而控制器驱动是platform_driver, 需要用platform_device或在设备树里提供硬件控制器的硬件资源.在H5的设备树sunxi-h3-h5.dtsi文件里,而描述好三个sd/mmc控制器的设备节点: mmc0: mmc@01c0f000 &#123; /* compatible and clocks are in per SoC .dtsi file */ reg = &lt;0x01c0f000 0x1000&gt;; resets = &lt;&amp;ccu RST_BUS_MMC0&gt;; reset-names = &quot;ahb&quot;; interrupts = &lt;GIC_SPI 60 IRQ_TYPE_LEVEL_HIGH&gt;; status = &quot;enabled&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; &#125;; mmc1: mmc@01c10000 &#123; /* compatible and clocks are in per SoC .dtsi file */ reg = &lt;0x01c10000 0x1000&gt;; resets = &lt;&amp;ccu RST_BUS_MMC1&gt;; reset-names = &quot;ahb&quot;; interrupts = &lt;GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH&gt;; status = &quot;enabled&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; &#125;; mmc2: mmc@01c11000 &#123; /* compatible and clocks are in per SoC .dtsi file */ reg = &lt;0x01c11000 0x1000&gt;; resets = &lt;&amp;ccu RST_BUS_MMC2&gt;; reset-names = &quot;ahb&quot;; interrupts = &lt;GIC_SPI 62 IRQ_TYPE_LEVEL_HIGH&gt;; status = &quot;enabled&quot;; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; &#125;;但三个设备节点的status属性值不是”okay”的话，是不会生效的. 而且还需要提供sd/mmc控制器使用的gpio口配置信息.在设备树文件sun50i-h5-nanopi-neo2.dts里，已提供让mmc0控制器生效的设备节点:&amp;mmc0 &#123; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;mmc0_pins_a&gt;, &lt;&amp;mmc0_cd_pin&gt;; vmmc-supply = &lt;&amp;reg_vcc3v3&gt;; bus-width = &lt;4&gt;; cd-gpios = &lt;&amp;pio 5 6 GPIO_ACTIVE_LOW&gt;; /* PF6 */ boot_device = &lt;1&gt;; status = &quot;okay&quot;;&#125;;所以要想使用mmc1控制器，再增加一个mmc的设备节点即可:&amp;mmc1 &#123; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;mmc1_pins_a&gt;; vmmc-supply = &lt;&amp;reg_vcc3v3&gt;; bus-width = &lt;4&gt;; status = &quot;okay&quot;;&#125;;修改完成后更新使用设备树，进入系统后://查看到已有两个设备与sd/mmc控制器的驱动匹配上了:^_^ / # ls /sys/bus/platform/drivers/sunxi-mmc/1c0f000.mmc/ 1c10000.mmc/ bind uevent unbindsd/mmc控制器驱动好后，它会自动读取sdio设备的信息，并在系统里创建出相应的sdio设备信息:这里可以获取到wifi芯片的厂家和设备id, wifi设备驱动里是根据这些id来作匹配的.^_^ / # cat /sys/bus/sdio/devices/mmc2\\:0001\\:1/device 0xf179^_^ / # cat /sys/bus/sdio/devices/mmc2\\:0001\\:1/vendor 0x024c通过官网的说明: http://linux-sunxi.org/Wifi#RTL8189FTVrtl8189ftv型号的wifi用的就是rtl8189ES驱动. 与型号8189fs一致.下载驱动源码: git clone https://github.com/jwrdegoede/rtl8189ES_linux.git git checkout -b rtl8189fs origin/rtl8189fs //下载8189fs的分支 git pull //检查更新1234驱动源码下载后， 可以发现此驱动源码是可以支持很多个型号的wifi芯片.在驱动源码os_dep/linux/sdio_intf.c文件里, 可以看到匹配用的设备id表: 47 static const struct sdio_device_id sdio_ids[] = 48 &#123; 49 #ifdef CONFIG_RTL8723B 50 &#123; SDIO_DEVICE(0x024c, 0xB723),.driver_data = RTL8723B&#125;, 51 #endif 52 #ifdef CONFIG_RTL8188E 53 &#123; SDIO_DEVICE(0x024c, 0x8179),.driver_data = RTL8188E&#125;, 54 #endif //CONFIG_RTL8188E 55 56 #ifdef CONFIG_RTL8821A 57 &#123; SDIO_DEVICE(0x024c, 0x8821),.driver_data = RTL8821&#125;, 58 #endif //CONFIG_RTL8821A 59 60 #ifdef CONFIG_RTL8192E 61 &#123; SDIO_DEVICE(0x024c, 0x818B),.driver_data = RTL8192E&#125;, 62 #endif //CONFIG_RTL8192E 63 64 #ifdef CONFIG_RTL8703B 65 &#123; SDIO_DEVICE(0x024c, 0xB703), .driver_data = RTL8703B&#125;, 66 #endif 67 68 #ifdef CONFIG_RTL8188F //rtl8189ftv的厂家和设备id 69 &#123;SDIO_DEVICE(0x024c, 0xF179), .driver_data = RTL8188F&#125;, 70 #endif .... 98 static struct sdio_drv_priv sdio_drvpriv = &#123; 99 .r871xs_drv.probe = rtw_drv_init, 100 .r871xs_drv.remove = rtw_dev_remove, 101 .r871xs_drv.name = (char*)DRV_NAME, 102 .r871xs_drv.id_table = sdio_ids, 103 #if (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,29)) 104 .r871xs_drv.drv = &#123; 105 .pm = &amp;rtw_sdio_pm_ops, 106 &#125; 107 #endif 108 &#125;;具体要编译支持哪个芯片，需要修改里面的Makefile.//只要作了git checkout … 里面会自动修改支持8189ftv/818fs的.Makefile里的内容: 38 CONFIG_RTL8188F = y 39 ######################### Interface ########################### 40 CONFIG_USB_HCI = n 41 CONFIG_PCI_HCI = n 42 CONFIG_SDIO_HCI = y//需要修改的内容: 114 CONFIG_PLATFORM_ARM_SUNxI = y ...1373 ARCH := arm641375 CROSS_COMPILE=aarch64-linux-gnu- ...1378 KSRC=~/fH5/NanoPi-NEO2/sources/linux/修改完成后，执行Makefile, 最终会生成8189fs.ko。在板上系统加载此驱动模块后，会有”wlan0”网络设备.————————————————版权声明：本文为CSDN博主「jklinux」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/jklinux/article/details/78737691","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"自动更新aria2的tracker list","slug":"auto-update-trackerlist","date":"2019-10-08T02:21:16.000Z","updated":"2019-10-08T02:23:26.923Z","comments":true,"path":"2019/10/08/auto-update-trackerlist/","permalink":"https://pazulin.github.io/2019/10/08/auto-update-trackerlist/","excerpt":"","keywords":null,"text":"(原文在这里)[https://stray.love/itshou-zha/wei-aria2-tian-jia-tracker-fu-wu-qi] 把下面脚本放入定时任务,然后通过rpc更新 ,简单方便快捷 12345678910#!/bin/sh#more trackers list, see https://github.com/ngosang/trackerslisttracker_url=&#x27;https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_all.txt&#x27;path=&#x27;http://10.10.10.5:6800/jsonrpc&#x27;passwd=&#x27;xxxxxx&#x27;tracker=$(echo -n $(curl -s -L $tracker_url | sed &#x27;N;s/\\n//g&#x27;) | tr &#x27; &#x27; &#x27;,&#x27;)[ -n &quot;$tracker&quot; ] &amp;&amp; curl $path -d &#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;aria2.changeGlobalOption&quot;,&quot;id&quot;:&quot;cron&quot;,&quot;params&quot;:[&quot;token:&#x27;$passwd&#x27;&quot;,&#123;&quot;bt-tracker&quot;:&quot;&#x27;$tracker&#x27;&quot;&#125;]&#125;&#x27;","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"矿渣猫盘安装aria2 + ariaNg + nginx","slug":"aria2-ariaNg","date":"2019-09-29T10:05:17.000Z","updated":"2019-09-30T01:41:12.032Z","comments":true,"path":"2019/09/29/aria2-ariaNg/","permalink":"https://pazulin.github.io/2019/09/29/aria2-ariaNg/","excerpt":"","keywords":null,"text":"利用猫盘做一个下载机,其实也没什么东西要下载,迅雷都可以,干嘛还要做这样一台机呢? 折腾罢了. aria2下载速度远远不如迅雷的,但是还要折腾这个,还是有一点比迅雷好的地方的,就是可以利用晚上时间下载. 猫盘刷debin系统, 不表. fireware在这里 然后apt instll aria2 nginx等组件. airaNg 的要手动下载,apt 安装不了. 重点说配置把,aria2 最重要就是配置文件,这个网上有, 主要事要做一个service加入系统服务中在&#x2F;etc&#x2F;systemd&#x2F;system 下面做一个aira2.service文件 123456789[Unit]Description=Aria2 ServiceAfter=network.target[Service]ExecStart=aria2c --enable-rpc=true --input-file=/root/aria2/aria2.session --conf-path=/root/aria2/aria2.conf[Install]WantedBy=multi-user.target 必须放入&#x2F;etc&#x2F;systemd&#x2F;system中,不要放入user文件夹中 ,会导致退出登录后无法连接到airaNg的问题. ariaNg 下载后&#x2F;var&#x2F;www&#x2F;html&#x2F;下面 ,不要放到其他地方,如果放到其他地方,nginx 要配置,当然如果你会配nginx,当我没说. 我比较懒,就不配了,自己放入,然后就可以访问.","raw":null,"content":null,"categories":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://pazulin.github.io/tags/linux/"}]},{"title":"用curl透过ftps 协议上传文件(vsftpd,ssh)","slug":"curl-ftps","date":"2019-09-06T07:58:03.000Z","updated":"2019-09-07T02:47:55.100Z","comments":true,"path":"2019/09/06/curl-ftps/","permalink":"https://pazulin.github.io/2019/09/06/curl-ftps/","excerpt":"","keywords":null,"text":"curl 不单单是下载工具,还可以上传,支持众多协议.我有一个摄像头接在ar9331 上面,跑mjpeg-stream,主要是拍照,监控淋花的情况,每天拍一张都两张照片,为什么不用现成的摄像头呢? 其实也可以,不过了,一来做来玩玩,另外一个可以把多年照片存起来,这个还是有点意思. 不说废话 在公司内网开内一个ftp服务器, 要端口映射到外网,这里面有点技巧,ftp现在都是加密的,要不然就太不安全. 必须ssh. 内网ftp服务器vsftpd的设置 &#x2F;etc&#x2F;vsftpd.conf 关键地方我用中文标记 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171# Example config file /etc/vsftpd.conf## The default compiled in settings are fairly paranoid. This sample file# loosens things up a bit, to make the ftp daemon more usable.# Please see vsftpd.conf.5 for all compiled in defaults.## READ THIS: This example file is NOT an exhaustive list of vsftpd options.# Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd&#x27;s# capabilities.### Run standalone? vsftpd can run either from an inetd or as a standalone# daemon started from an initscript.listen=Yes 关闭ipv6 后必须打开这个## This directive enables listening on IPv6 sockets. By default, listening# on the IPv6 &quot;any&quot; address (::) will accept connections from both IPv6# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6# sockets. If you want that (perhaps because you want to listen on specific# addresses) then you must run two copies of vsftpd with two configuration# files.listen_ipv6=No 必须关闭ipv6 ,否则最后传不到实际外网的ip地址## Allow anonymous FTP? (Disabled by default).anonymous_enable=NO## Uncomment this to allow local users to log in.local_enable=YES## Uncomment this to enable any form of FTP write command.write_enable=YES## Default umask for local users is 077. You may wish to change this to 022,# if your users expect that (022 is used by most other ftpd&#x27;s)local_umask=022## Uncomment this to allow the anonymous FTP user to upload files. This only# has an effect if the above global write enable is activated. Also, you will# obviously need to create a directory writable by the FTP user.#anon_upload_enable=YES## Uncomment this if you want the anonymous FTP user to be able to create# new directories.#anon_mkdir_write_enable=YES## Activate directory messages - messages given to remote users when they# go into a certain directory.dirmessage_enable=YES## If enabled, vsftpd will display directory listings with the time# in your local time zone. The default is to display GMT. The# times returned by the MDTM FTP command are also affected by this# option.use_localtime=YES## Activate logging of uploads/downloads.xferlog_enable=YES## Make sure PORT transfer connections originate from port 20 (ftp-data).connect_from_port_20=YES## If you want, you can arrange for uploaded anonymous files to be owned by# a different user. Note! Using &quot;root&quot; for uploaded files is not# recommended!#chown_uploads=YES#chown_username=whoever## You may override where the log file goes if you like. The default is shown# below.#xferlog_file=/var/log/vsftpd.log## If you want, you can have your log file in standard ftpd xferlog format.# Note that the default log file location is /var/log/xferlog in this case.#xferlog_std_format=YES## You may change the default value for timing out an idle session.#idle_session_timeout=600## You may change the default value for timing out a data connection.#data_connection_timeout=120## It is recommended that you define on your system a unique user which the# ftp server can use as a totally isolated and unprivileged user.#nopriv_user=ftpsecure## Enable this and the server will recognise asynchronous ABOR requests. Not# recommended for security (the code is non-trivial). Not enabling it,# however, may confuse older FTP clients.#async_abor_enable=YES## By default the server will pretend to allow ASCII mode but in fact ignore# the request. Turn on the below options to have the server actually do ASCII# mangling on files when in ASCII mode.# Beware that on some FTP servers, ASCII support allows a denial of service# attack (DoS) via the command &quot;SIZE /big/file&quot; in ASCII mode. vsftpd# predicted this attack and has always been safe, reporting the size of the# raw file.# ASCII mangling is a horrible feature of the protocol.#ascii_upload_enable=YES#ascii_download_enable=YES## You may fully customise the login banner string:#ftpd_banner=Welcome to blah FTP service.## You may specify a file of disallowed anonymous e-mail addresses. Apparently# useful for combatting certain DoS attacks.#deny_email_enable=YES# (default follows)#banned_email_file=/etc/vsftpd.banned_emails## You may restrict local users to their home directories. See the FAQ for# the possible risks in this before using chroot_local_user or# chroot_list_enable below.#chroot_local_user=YES## You may specify an explicit list of local users to chroot() to their home# directory. If chroot_local_user is YES, then this list becomes a list of# users to NOT chroot().# (Warning! chroot&#x27;ing can be very dangerous. If using chroot, make sure that# the user does not have write access to the top level directory within the# chroot)chroot_local_user=YES#chroot_list_enable=YES# (default follows)chroot_list_file=/etc/vsftpd.chroot_list## You may activate the &quot;-R&quot; option to the builtin ls. This is disabled by# default to avoid remote users being able to cause excessive I/O on large# sites. However, some broken FTP clients such as &quot;ncftp&quot; and &quot;mirror&quot; assume# the presence of the &quot;-R&quot; option, so there is a strong case for enabling it.#ls_recurse_enable=YES## Customization## Some of vsftpd&#x27;s settings don&#x27;t fit the filesystem layout by# default.## This option should be the name of a directory which is empty. Also, the# directory should not be writable by the ftp user. This directory is used# as a secure chroot() jail at times vsftpd does not require filesystem# access.secure_chroot_dir=/var/run/vsftpd/empty## This string is the name of the PAM service vsftpd will use.pam_service_name=vsftpd## This option specifies the location of the RSA certificate to use for SSL# encrypted connections.rsa_cert_file=/etc/ssl/certs/xxxxx.pemrsa_private_key_file=/etc/ssl/private/xxxx.keyssl_enable=Yesforce_local_data_ssl=Yesforce_local_logins_ssl=Yesssl_tlsv1=Yes## Uncomment this to indicate that vsftpd use a utf8 filesystem.utf8_filesystem=YESuserlist_enable=Yesuserlist_deny=Nouserlist_file=/etc/vsftpd.user_listallow_writeable_chroot=Yespasv_enable=Yeslisten_port=??? //看需要pasv_max_port=???? //看需要pasv_min_port=???? //看需要pasv_addr_resolve=Yes // 必须用这个 , 否则下面要填实际ip,但是动态ip怎么可能有ip , 这是pasv 模式下,回传给客户段的ip地址,pasv_address=abc.com // 可以填域名,必须有上面那个yes 然后把端口映射一下. 然后利用curl 上传,curl 是支持加密ftp的. 12curl -k --ftp-ssl --ftp-ssl-reqd --ftp-create-dirs -T xxx.jpg -u user:password ftp://abcd.com:1000/ -k 是忽略证书检查, 是ftp:&#x2F;&#x2F; 不是ftps.","raw":null,"content":null,"categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/tags/openwrt/"}]},{"title":"Hex Editor 的几个事项","slug":"hex-edit","date":"2019-09-06T03:00:19.000Z","updated":"2019-09-06T03:05:23.777Z","comments":true,"path":"2019/09/06/hex-edit/","permalink":"https://pazulin.github.io/2019/09/06/hex-edit/","excerpt":"","keywords":null,"text":"要提取702N 后64K的art部分 ,需要用hex editor, vscode 有一个hexdump的插件,不过不能复制截取, notepad++ 也有hexeditor的插件,不过搞来搞去都安装不成功,算了,那些事情就不说了,安装成功后,也没什么用,也非常不稳定,一下崩了. 最后还是用 HxD 这个免费的hex editor. 当然ultraEdit 也可以, 不过不免费,我也懒得用了.","raw":null,"content":null,"categories":[{"name":"PC","slug":"PC","permalink":"https://pazulin.github.io/categories/PC/"}],"tags":[{"name":"PC","slug":"PC","permalink":"https://pazulin.github.io/tags/PC/"}]},{"title":"获取mjpeg 照片脚本","slug":"cat-image","date":"2019-09-04T08:35:05.000Z","updated":"2019-09-04T08:36:36.714Z","comments":true,"path":"2019/09/04/cat-image/","permalink":"https://pazulin.github.io/2019/09/04/cat-image/","excerpt":"","keywords":null,"text":"用时间作为文件夹和文件名 123456789101112131415#!/bin/shfolder=$(date &quot;+%Y%m%d&quot;)filename=$(date &quot;+%Y%m%d%H%M%S.jpg&quot;)#echo $filename $folderif test -e /mnt/sda1/$folder then echo &quot;folder exits&quot;else mkdir /mnt/sda1/$folderfiwget --o /mnt/sda1/$folder/$filename http://localhost:8080/?action=snapshot","raw":null,"content":null,"categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/tags/openwrt/"}]},{"title":"nodemcu 运行 mqtt 做控制","slug":"nodemcu-mqtt","date":"2019-08-29T04:38:00.000Z","updated":"2019-08-29T04:57:01.600Z","comments":true,"path":"2019/08/29/nodemcu-mqtt/","permalink":"https://pazulin.github.io/2019/08/29/nodemcu-mqtt/","excerpt":"","keywords":null,"text":"之前淋花, 控制灯的开关 都是nodemcu 做的,但是都是基于cron服务. 也就是定时服务. 定时服务简单,就是一个缺点,有时候这些东西要修改的时候比较麻烦, 要接上串口修改, 不接上串口 ,用telnet 去改也就可以但是总没那么直观,很容易出错而不知. 上去家中花严重缺水, 原来上次淋花器的一个程序有问题, 自己修改的时候不够细心,出错,倒是一个多月缺水, 于是下定决心修改一下. 现在把所有控制器都改到用mqtt协议连接到mqtt server上面, mqtt server 是自己搭建的. 运行在一个openwrt路由器上, 域名是阿里云域名,然后自己动态更新. 电信网络有公网IP ,于是就有了一些列的服务. nodemcu 连接到mqtt server 上面,然后所有动作,都由服务器的cron 服务统一操作. 这样随时可以修改动作的时间,内容. 方便多了. 具体来说, 而且还可以根据当天天气清空改变淋花次数, 改变喂鱼机投喂次数, 比如天气寒冷,停止投喂. 代码init.lua 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109--init for water gpio.mode(5, gpio.OUTPUT);--gpio.mode(4, gpio.OUTPUT);gpio.write(5, gpio.LOW);station_cfg=&#123;&#125;station_cfg.ssid=&quot;sdfasd&quot;;station_cfg.pwd=&quot;fasdfa&quot;-- 标识mqtt是否已经初始化mqtt_inited = 0-- 标识mqtt 是否已经连接mqtt_connecting = 0function startup() -- if file.open(&quot;init.lua&quot;) == nil then --print(&quot;init.lua deleted or renamed&quot;) --else --print(&quot;Running&quot;) --file.close(&quot;init.lua&quot;) -- the actual application is stored in &#x27;application.lua&#x27; -- dofile(&quot;application.lua&quot;) --end dofile(&quot;synctime.lua&quot;); mdns.register(&quot;water&quot;, &#123;hardware=&#x27;NodeMCU&#x27;&#125;); print(&quot;mdns:water.local/&quot;); print(&quot;connecting mqtt server&quot;); dofile(&quot;mqtt.lua&quot;)end-- Define WiFi station event callbacks wifi_connect_event = function(T) print(&quot;Connection to AP(&quot;..T.SSID..&quot;) established!&quot;) print(&quot;Waiting for IP address...&quot;) if disconnect_ct ~= nil then disconnect_ct = nil end endwifi_got_ip_event = function(T) -- Note: Having an IP address does not mean there is internet access! -- Internet connectivity can be determined with net.dns.resolve(). print(&quot;Wifi connection is ready! IP address is: &quot;..T.IP) print(&quot;Startup will resume momentarily, you have 3 seconds to abort.&quot;) print(&quot;Waiting...&quot;) tmr.create():alarm(3000, tmr.ALARM_SINGLE, startup)endwifi_disconnect_event = function(T) if T.reason == wifi.eventmon.reason.ASSOC_LEAVE then --the station has disassociated from a previously connected AP return end -- total_tries: how many times the station will attempt to connect to the AP. Should consider AP reboot duration. local total_tries = 5000 print(&quot;\\nWiFi connection to AP(&quot;..T.SSID..&quot;) has failed!&quot;) wifi_connetion1=0; --There are many possible disconnect reasons, the following iterates through --the list and returns the string corresponding to the disconnect reason. for key,val in pairs(wifi.eventmon.reason) do if val == T.reason then print(&quot;Disconnect reason: &quot;..val..&quot;(&quot;..key..&quot;)&quot;) break end end --if disconnect_ct == nil then -- disconnect_ct = 1 -- else --disconnect_ct = disconnect_ct + 1 --end --if disconnect_ct &lt; total_tries then -- print(&quot;Retrying connection...(attempt &quot;..(disconnect_ct+1)..&quot; of &quot;..total_tries..&quot;)&quot;) --else-- wifi.sta.disconnect() --print(&quot;Aborting connection to AP!&quot;) --disconnect_ct = nil --endend-- Register WiFi Station event callbackswifi.eventmon.register(wifi.eventmon.STA_CONNECTED, wifi_connect_event)wifi.eventmon.register(wifi.eventmon.STA_GOT_IP, wifi_got_ip_event)wifi.eventmon.register(wifi.eventmon.STA_DISCONNECTED, wifi_disconnect_event)print(&quot;Connecting to WiFi access point...&quot;)wifi.setmode(wifi.STATION)wifi.sta.config(station_cfg)wifi.sta.autoconnect(1)-- wifi.sta.connect() not necessary because config() uses auto-connect=true by defaultdofile(&quot;http.lua&quot;);print(&quot;runing http&quot;);dofile(&quot;task.lua&quot;);print(&quot;runing cron task&quot;);dofile(&quot;telnet.lua&quot;);print(&quot;runing telnet server&quot;); mqtt.lua 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119function stopReconnect() -- clear connecting state and clear connect timer! mqtt_connecting = 0 tmr.stop(3)end-- 重连方法function reconnect() if mqtt_connecting == 0 then tmr.alarm(3, 20000, 1, function() print(&quot;start mqtt server reconnect!&quot;) mq:close() mq:connect(&quot;x.x.x.x&quot;, 1883, 0) end) mqtt_connecting = 1 endend-- 初始化mqtt连接方法function init() print(&quot;init mqtt&quot;) mqtt_inited = 1 -- 初始化无需登陆的客户端, 心跳时间 120秒 mq = mqtt.Client(&quot;recv_earth1&quot;, 120) --mq:lwt(&quot;/lwt&quot;, &quot;offline&quot;, 0, 0) -- 设置连接ip 以及 端口 -- 对于 TLS: m:connect(&quot;192.168.11.118&quot;, secure-port, 1) mq:connect(&quot;192.168.1.1&quot;, 1883, 0, function(client) print(&quot;connected&quot;) end, function(client, reason) print(&quot;failed reason: &quot; .. reason) reconnect() end ) --连接到服务器触发事件 mq:on(&quot;connect&quot;, function(client) print(&quot;connected&quot;) stopReconnect() mq:subscribe(&quot;tai3_water&quot;,0, function(conn) print(&quot;subscribe success&quot;) end) --mq:subscribe(&quot;rpt_temp&quot;,0, function(conn) print(&quot;subscribe success&quot;) end) end) mq:on(&quot;offline&quot;, function(client) print (&quot;offline&quot;) reconnect() end) --掉线触发事件-- 收到消息时触发事件mq:on(&quot;message&quot;, function(client, topic, data) print(topic .. &quot;:&quot; ) if data ~= nil then if topic == &quot;tai3_water&quot; then print(data) if data == &quot;water1min&quot; then dofile(&quot;water.lua&quot;) --mq:publish(&quot;report_info&quot;,&quot;tai3_water1&quot;,0,0) elseif data == &quot;water2min&quot; then dofile(&quot;water2.lua&quot;) --mq:publish(&quot;report_info&quot;,&quot;tai3_water2&quot;,0,0) elseif data == &quot;water4min&quot; then dofile(&quot;water4.lua&quot;) --mq:publish(&quot;report_info&quot;,&quot;tai3_water4&quot;,0,0) end end --if topic == &quot;rpt_water&quot; and tonumber(data) &gt; 12 then --print(&quot;aaa&quot;..data) --end endend)end--function do_get_adc() -- 定义定时器处理函数 --mq:publish(&quot;rpt_water&quot;, adc.read(0), 0, 0) --end --tmr.create():alarm(60000, tmr.ALARM_AUTO , do_get_adc)-- 确保subscribe/publish方法在连接上服务器后再调用，在实际应用中是把他们放在connect回调函数里或者确定连接成功-- 订阅/topic主题、服务质量为0--m:subscribe(&quot;topicxx&quot;,0, function(conn) print(&quot;subscribe success&quot;) end)--m:subscribe(&quot;blinkdr&quot;,0, function(conn) print(&quot;subscribe success&quot;) end)-- 发送一条信息 data = hello, QoS = 0, retain = 0--m:close();-- 你可以再次调用 m:connect 连接函数-- 如果没有初始化过，进行初始化if mqtt_inited == 0 then init()else reconnect()end synctime.lua 123456789101112131415161718local tmlocal secsec=rtctime.get();rtctime.set(0);sntp.sync(&quot;ntp1.aliyun.com&quot;, function() -- success rtctime.set(rtctime.get() + 8*3600 , 0) tm = rtctime.epoch2cal(rtctime.get()) print(string.format(&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;, tm[&quot;year&quot;], tm[&quot;mon&quot;], tm[&quot;day&quot;], tm[&quot;hour&quot;], tm[&quot;min&quot;], tm[&quot;sec&quot;])) end, function() -- fail rtctime.set(sec); print(&quot;fail!&quot;); end ) task.lua 12345678910111213141516171819202122232425262728293031323334353637383940414243cron.schedule(&quot;1 5 */2 * *&quot;, function(e) dofile(&quot;synctime.lua&quot;);end)--cron.schedule(&quot;*/15 * * * *&quot;, function(e)-- dofile(&quot;imap_read.lua&quot;);--end)cron.schedule(&quot;1 8 * * *&quot;, function(e) if mqtt_connecting == 1 then dofile(&quot;water2.lua&quot;); endend)--cron.schedule(&quot;1 9 * * *&quot;, function(e)-- dofile(&quot;water.lua&quot;);--end)cron.schedule(&quot;1 11 * * *&quot;, function(e) if mqtt_connecting == 1 then dofile(&quot;water2.lua&quot;); end end)--cron.schedule(&quot;1 12 * * *&quot;, function(e)-- dofile(&quot;water.lua&quot;);--end)cron.schedule(&quot;30 17 * * *&quot;, function(e) if mqtt_connecting == 1 then dofile(&quot;water2.lua&quot;); endend)--cron.schedule(&quot;30 18 * * *&quot;, function(e) --dofile(&quot;water.lua&quot;);--end)","raw":null,"content":null,"categories":[{"name":"nodemcu","slug":"nodemcu","permalink":"https://pazulin.github.io/categories/nodemcu/"}],"tags":[{"name":"nodemcu","slug":"nodemcu","permalink":"https://pazulin.github.io/tags/nodemcu/"}]},{"title":"ddns 动态更新ip的脚本","slug":"ddns-update-ip-sh","date":"2019-08-22T09:04:42.000Z","updated":"2019-08-22T09:06:29.115Z","comments":true,"path":"2019/08/22/ddns-update-ip-sh/","permalink":"https://pazulin.github.io/2019/08/22/ddns-update-ip-sh/","excerpt":"","keywords":null,"text":"12345678910111213141516171819202122232425262728293031#!/bin/sh# check ip change and update itip_regex=&quot;[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;&quot; ipaddr=$(ifconfig pppoe-wan | awk &#x27;/inet /&#123;print $2&#125;&#x27; |grep -o &quot;$ip_regex&quot; )old_ipaddr=$(ping -c 1 kang.ddns.info|head -1 | grep -o &quot;$ip_regex&quot;)if [ &quot;$ipaddr&quot; != &quot;$old_ipaddr&quot; ];then# 发邮件echo &quot;Subject:$ipaddr&quot; | ssmtp -v robot12123@334343.net # 更新wget -q -O /tmp/ddns --no-check-certificate &#x27;https://nic.changeip.com/nic/update?u=XXX&amp;p=XXX&amp;hotname=kk&#x27; fi","raw":null,"content":null,"categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/tags/openwrt/"}]},{"title":"wr842n_v4.4 烧入 openwrt","slug":"wr842n-v4-openwrt","date":"2019-08-13T03:47:26.000Z","updated":"2019-08-13T04:02:46.775Z","comments":true,"path":"2019/08/13/wr842n-v4-openwrt/","permalink":"https://pazulin.github.io/2019/08/13/wr842n-v4-openwrt/","excerpt":"","keywords":null,"text":"wr842n 缩水很严重, 把ram拆下来改成64MB , flash 改成25Q128 16m 版本, 当然,芯片要用编程序写入breed, 然后再焊上去, 结果写入固件后不断重启, 查来查去 ,原来没有烧入art 文件 art 是无线部分的特性参数的文件,网上做breed的大神有, 我是下载来的,我提供一份把,这里 原链接在这里 在breed 中更新qca9533的art文件后,正常启动. 固件?固件就是opwnwrt 官网固件,我写入是18.XX版本, 我是用来做MTQQ server 的, 所以其他功能没有测试.","raw":null,"content":null,"categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/tags/openwrt/"}]},{"title":"ssmtp 配置","slug":"ssmtp-conf","date":"2019-08-07T04:49:53.000Z","updated":"2019-08-09T03:56:18.901Z","comments":true,"path":"2019/08/07/ssmtp-conf/","permalink":"https://pazulin.github.io/2019/08/07/ssmtp-conf/","excerpt":"","keywords":null,"text":"ssmtp 是一个简单发邮件工具, 配置&#x2F;etc&#x2F;ssmtp&#x2F;ssmtp.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748## /etc/ssmtp.conf -- a config file for sSMTP sendmail.## The person who gets all mail for userids &lt; 1000# Make this empty to disable rewriting.root=robot123456@kaudioxxyyzz.net# The place where the mail goes. The actual machine name is required# no MX records are consulted. Commonly mailhosts are named mail.domain.com# The example will fit if you are in domain.com and your mailhub is so named.mailhub=smtp.kaudioxxyyzz.net# Example for SMTP port number 2525# mailhub=mail.your.domain:2525# Example for SMTP port number 25 (Standard/RFC)# mailhub=mail.your.domain# Example for SSL encrypted connection# mailhub=mail.your.domain:465# Where will the mail seem to come from?rewriteDomain=kaudioxxyyzz.net# The full hostnamehostname=kaudioxxyyzz.net# Set this to never rewrite the &quot;From:&quot; line (unless not given) and to# use that address in the &quot;from line&quot; of the envelope.FromLineOverride=YES# Use SSL/TLS to send secure messages to server.#UseTLS=YES# Use SSL/TLS certificate to authenticate against smtp host.#UseTLSCert=YES# Use this RSA certificate.#TLSCert=/etc/ssl/certs/ssmtp.pem# Get enhanced (*really* enhanced) debugging information in the logs# If you want to have debugging of the config file parsing, move this option# to the top of the config file and uncomment#Debug=YESAuthUser=robot1234576@kaudioxxyyzz.netAuthPass=pw &#x2F;etc&#x2F;ssmtp&#x2F;revaliases 123456789# sSMTP aliases## Format: local_account:outgoing_address:mailhub## Example: root:your_login@your.domain:mailhub.your.domain[:port]# where [:port] is an optional port number that defaults to 25.root:robot1111111@kaudiofdsafasd.net:smtp.kaudioafsdfasdf.net","raw":null,"content":null,"categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/tags/openwrt/"}]},{"title":"利用阿里云 OpenAPI 以及 DNS 云解析自建 DDNS 运行在路由器之尝试","slug":"aliyun-ddns","date":"2019-08-05T10:20:47.000Z","updated":"2019-08-08T05:00:54.515Z","comments":true,"path":"2019/08/05/aliyun-ddns/","permalink":"https://pazulin.github.io/2019/08/05/aliyun-ddns/","excerpt":"","keywords":null,"text":"原文章在 不过我尝试安装openwrt 路由器上 首先openwrt 的路由器空间必须大,我是安装在u盘上的,可能要10M左右空间 ,python安装也占不少空间. 程序中用到阿里云的库, aliyunsdkcore 和aliyunsdkalidns , 之前有人用pip 安装,但是openwrt 上不能, 所以下载其源码,然后解压后, 把里面核心代码复制到 &#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;XXXX (后面路径不记得) ,我看见别人自己提取相关几个文件,放在当前目录也可以. update_ip.py 这个基本上来自前面那个文章,只不过我因为跑在openwrt上, 所以我改了获取ip的方式,改有get_ip这个脚本获取. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/usr/bin/env python# coding= utf-8import subprocessimport osimport json#from urllib2 import urlopenfrom aliyunsdkcore.client import AcsClientfrom aliyunsdkcore.acs_exception.exceptions import ClientExceptionfrom aliyunsdkcore.acs_exception.exceptions import ServerExceptionfrom aliyunsdkalidns.request.v20150109 import DescribeDomainRecordsRequestfrom aliyunsdkalidns.request.v20150109 import UpdateDomainRecordRequestclass DnsHandler: # 从阿里云开发者后台获取Access_Key_Id和Access_Key_Secret access_key_id = &quot;&quot; access_key_secret = &quot;&quot; region_id = &quot;cn-hangzhou&quot; # 填入自己的域名 domain_name = &quot;&quot; # 填入二级域名的RR值 rr_keyword = &quot;&quot; # 解析记录类型，一般为A记录 record_type = &quot;A&quot; # 用于储存解析记录的文件名 file_name = &quot;.ip_addr&quot; client = None record = None current_ip = &#x27;&#x27; # 初始化，获取client实例 def __init__(self): self.client = AcsClient( self.access_key_id, self.access_key_secret, self.region_id ) self.record = self.get_record() self.current_ip = self.get_current_ip() # 如果公网IP发生变化，则自动修改阿里云解析记录 def reset(self): if self.current_ip &lt;&gt; self.get_record_value(): # print self.current_ip print self.update_record(self.current_ip) self.get_record() # 获取阿里云域名解析完整记录，并使用文件缓存 def get_record(self): if os.path.isfile(self.file_name) : file_handler = open(self.file_name, &#x27;r&#x27;) r = file_handler.read() file_handler.close() else : request = DescribeDomainRecordsRequest.DescribeDomainRecordsRequest() request.set_PageSize(10) request.set_action_name(&quot;DescribeDomainRecords&quot;) request.set_DomainName(self.domain_name) request.set_RRKeyWord(self.rr_keyword) request.set_TypeKeyWord(self.record_type) r = self.client.do_action_with_exception(request) file_handler = open(self.file_name, &#x27;w&#x27;) file_handler.write(r) file_handler.close() return json.loads(r) # 获取阿里云域名解析记录ID def get_record_id(self) : return self.record[&quot;DomainRecords&quot;][&quot;Record&quot;][0][&quot;RecordId&quot;] # 获取当前域名解析记录 def get_record_value(self) : return self.record[&quot;DomainRecords&quot;][&quot;Record&quot;][0][&quot;Value&quot;] # 修改阿里云解析记录 def update_record(self, value): request = UpdateDomainRecordRequest.UpdateDomainRecordRequest() request.set_action_name(&quot;UpdateDomainRecord&quot;) request.set_RecordId(self.get_record_id()) request.set_Type(self.record_type) request.set_RR(self.rr_keyword) request.set_Value(value) return self.client.do_action_with_exception(request) # 获取当前公网IP def get_current_ip(self): #ip,retcode=os.system(&#x27;./get_ip&#x27;) out_bytes=subprocess.check_output(&#x27;/root/get_ip&#x27;) out_text= out_bytes.decode(&#x27;utf8&#x27;) out_text=out_text.replace(&quot;\\n&quot;,&quot;&quot;) #print out_text #out_text.replace(&quot;\\n&quot;,&quot;&quot;).replace(&quot;\\r&quot;,&quot;&quot;) return out_text # //json.load(urlopen(&#x27;http://jsonip.com&#x27;))[&#x27;ip&#x27;# 实例化类并启动更新程序dns = DnsHandler()dns.reset() 123456789#!/bin/sh# check ip change and update itip_regex=&quot;[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;&quot; ipaddr=$(ifconfig pppoe-wan | awk &#x27;/inet /&#123;print $2&#125;&#x27; |grep -o &quot;$ip_regex&quot; )echo $ipaddr 然后加到cron 里面*&#x2F;15 * * * * python &#x2F;root&#x2F;update_ip.py","raw":null,"content":null,"categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/tags/openwrt/"}]},{"title":"rg100a comm run 400mhz","slug":"rg100a-comm","date":"2019-08-05T03:00:21.000Z","updated":"2019-08-05T03:07:18.135Z","comments":true,"path":"2019/08/05/rg100a-comm/","permalink":"https://pazulin.github.io/2019/08/05/rg100a-comm/","excerpt":"","keywords":null,"text":"1.拆开接上串口，见以前的图，打开串口，重启rg100a，按回车，让其不要启动linux，在cfe控制界面停下来。2.接上网络，登录192.168.1.1. 3，输入下面中的其中一个用户密码登录进去。 USER&#x3D;telecomadmin pass&#x3D;telecomadmin 2:user&#x3D;telecomadmin pass&#x3D;nE7jA%5m 3:user&#x3D;bjcnchgw pass&#x3D;8mCnC@bj 上次文件，更新系统。在串口哪里，可以看到更新过程，然后自动重启。 R206，R207，R208，R209各焊上4.7K贴片电阻。成功超频400MHZ","raw":null,"content":null,"categories":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/categories/openwrt/"}],"tags":[{"name":"openwrt","slug":"openwrt","permalink":"https://pazulin.github.io/tags/openwrt/"}]},{"title":"Volumio install in Orange Pi Zero","slug":"volumio-orangepizero","date":"2019-08-01T03:50:29.000Z","updated":"2019-08-01T04:36:44.278Z","comments":true,"path":"2019/08/01/volumio-orangepizero/","permalink":"https://pazulin.github.io/2019/08/01/volumio-orangepizero/","excerpt":"","keywords":null,"text":"Volumio 没有对应的Zero 的版本,但是又lite 板 ,Lite 是H3 cpu , 和H2 的Zero相比应该是可以运行的, 在volumio的论坛上又lite版的移植 在这里volumio for orangepi 烧入SD启动就可以, 设置里面选择I2S-master, 我用的是PCM5102的DA 底噪不明显,示波器看BCK 不稳 , Allwinner 的CPU就这个德行? 怎么做Hifi 啊?? 不知树莓派如何. 勉强先用.另外一个要命的问题, volumio是utf8, mount nas的时候也是utf8 .这也算了, ssh登录后台,手动mount cifs -o charset&#x3D;cp936 竟然不能正常mount, 不知为何. 所以有些中文文件名无法显示,有些却正常,不知为何, 另外最麻烦的是ape文件中的cue文件,里面全是gb2312的,在volumio里面全部乱码.这怎么用啊?","raw":null,"content":null,"categories":[{"name":"我的作品","slug":"我的作品","permalink":"https://pazulin.github.io/categories/%E6%88%91%E7%9A%84%E4%BD%9C%E5%93%81/"}],"tags":[{"name":"OrangePi","slug":"OrangePi","permalink":"https://pazulin.github.io/tags/OrangePi/"}]},{"title":"新的blog","slug":"first-test","date":"2019-07-31T09:28:09.000Z","updated":"2019-07-31T09:44:37.162Z","comments":true,"path":"2019/07/31/first-test/","permalink":"https://pazulin.github.io/2019/07/31/first-test/","excerpt":"","keywords":null,"text":"新做的blog 不知道好不好, 先试试, 但是存在一个问题,这个blog 要hexo 支持, 如果在另外一台电脑 , 那不是写不了?","raw":null,"content":null,"categories":[],"tags":[]}]}